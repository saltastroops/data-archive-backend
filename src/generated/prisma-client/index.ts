// Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  dataFile: (where?: DataFileWhereInput) => Promise<boolean>;
  dataRequest: (where?: DataRequestWhereInput) => Promise<boolean>;
  dataRequestPart: (where?: DataRequestPartWhereInput) => Promise<boolean>;
  header: (where?: HeaderWhereInput) => Promise<boolean>;
  observation: (where?: ObservationWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  proposal: (where?: ProposalWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  dataFile: (where: DataFileWhereUniqueInput) => DataFilePromise;
  dataFiles: (
    args?: {
      where?: DataFileWhereInput;
      orderBy?: DataFileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DataFile>;
  dataFilesConnection: (
    args?: {
      where?: DataFileWhereInput;
      orderBy?: DataFileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DataFileConnectionPromise;
  dataRequest: (where: DataRequestWhereUniqueInput) => DataRequestPromise;
  dataRequests: (
    args?: {
      where?: DataRequestWhereInput;
      orderBy?: DataRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DataRequest>;
  dataRequestsConnection: (
    args?: {
      where?: DataRequestWhereInput;
      orderBy?: DataRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DataRequestConnectionPromise;
  dataRequestPart: (
    where: DataRequestPartWhereUniqueInput
  ) => DataRequestPartPromise;
  dataRequestParts: (
    args?: {
      where?: DataRequestPartWhereInput;
      orderBy?: DataRequestPartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DataRequestPart>;
  dataRequestPartsConnection: (
    args?: {
      where?: DataRequestPartWhereInput;
      orderBy?: DataRequestPartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DataRequestPartConnectionPromise;
  header: (where: HeaderWhereUniqueInput) => HeaderPromise;
  headers: (
    args?: {
      where?: HeaderWhereInput;
      orderBy?: HeaderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Header>;
  headersConnection: (
    args?: {
      where?: HeaderWhereInput;
      orderBy?: HeaderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HeaderConnectionPromise;
  observation: (where: ObservationWhereUniqueInput) => ObservationPromise;
  observations: (
    args?: {
      where?: ObservationWhereInput;
      orderBy?: ObservationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Observation>;
  observationsConnection: (
    args?: {
      where?: ObservationWhereInput;
      orderBy?: ObservationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ObservationConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonPromise;
  persons: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Person>;
  personsConnection: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PersonConnectionPromise;
  proposal: (where: ProposalWhereUniqueInput) => ProposalPromise;
  proposals: (
    args?: {
      where?: ProposalWhereInput;
      orderBy?: ProposalOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Proposal>;
  proposalsConnection: (
    args?: {
      where?: ProposalWhereInput;
      orderBy?: ProposalOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProposalConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDataFile: (data: DataFileCreateInput) => DataFilePromise;
  updateDataFile: (
    args: { data: DataFileUpdateInput; where: DataFileWhereUniqueInput }
  ) => DataFilePromise;
  updateManyDataFiles: (
    args: { data: DataFileUpdateManyMutationInput; where?: DataFileWhereInput }
  ) => BatchPayloadPromise;
  upsertDataFile: (
    args: {
      where: DataFileWhereUniqueInput;
      create: DataFileCreateInput;
      update: DataFileUpdateInput;
    }
  ) => DataFilePromise;
  deleteDataFile: (where: DataFileWhereUniqueInput) => DataFilePromise;
  deleteManyDataFiles: (where?: DataFileWhereInput) => BatchPayloadPromise;
  createDataRequest: (data: DataRequestCreateInput) => DataRequestPromise;
  updateDataRequest: (
    args: { data: DataRequestUpdateInput; where: DataRequestWhereUniqueInput }
  ) => DataRequestPromise;
  updateManyDataRequests: (
    args: {
      data: DataRequestUpdateManyMutationInput;
      where?: DataRequestWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDataRequest: (
    args: {
      where: DataRequestWhereUniqueInput;
      create: DataRequestCreateInput;
      update: DataRequestUpdateInput;
    }
  ) => DataRequestPromise;
  deleteDataRequest: (where: DataRequestWhereUniqueInput) => DataRequestPromise;
  deleteManyDataRequests: (
    where?: DataRequestWhereInput
  ) => BatchPayloadPromise;
  createDataRequestPart: (
    data: DataRequestPartCreateInput
  ) => DataRequestPartPromise;
  updateDataRequestPart: (
    args: {
      data: DataRequestPartUpdateInput;
      where: DataRequestPartWhereUniqueInput;
    }
  ) => DataRequestPartPromise;
  updateManyDataRequestParts: (
    args: {
      data: DataRequestPartUpdateManyMutationInput;
      where?: DataRequestPartWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDataRequestPart: (
    args: {
      where: DataRequestPartWhereUniqueInput;
      create: DataRequestPartCreateInput;
      update: DataRequestPartUpdateInput;
    }
  ) => DataRequestPartPromise;
  deleteDataRequestPart: (
    where: DataRequestPartWhereUniqueInput
  ) => DataRequestPartPromise;
  deleteManyDataRequestParts: (
    where?: DataRequestPartWhereInput
  ) => BatchPayloadPromise;
  createHeader: (data: HeaderCreateInput) => HeaderPromise;
  updateHeader: (
    args: { data: HeaderUpdateInput; where: HeaderWhereUniqueInput }
  ) => HeaderPromise;
  updateManyHeaders: (
    args: { data: HeaderUpdateManyMutationInput; where?: HeaderWhereInput }
  ) => BatchPayloadPromise;
  upsertHeader: (
    args: {
      where: HeaderWhereUniqueInput;
      create: HeaderCreateInput;
      update: HeaderUpdateInput;
    }
  ) => HeaderPromise;
  deleteHeader: (where: HeaderWhereUniqueInput) => HeaderPromise;
  deleteManyHeaders: (where?: HeaderWhereInput) => BatchPayloadPromise;
  createObservation: (data: ObservationCreateInput) => ObservationPromise;
  updateObservation: (
    args: { data: ObservationUpdateInput; where: ObservationWhereUniqueInput }
  ) => ObservationPromise;
  updateManyObservations: (
    args: {
      data: ObservationUpdateManyMutationInput;
      where?: ObservationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertObservation: (
    args: {
      where: ObservationWhereUniqueInput;
      create: ObservationCreateInput;
      update: ObservationUpdateInput;
    }
  ) => ObservationPromise;
  deleteObservation: (where: ObservationWhereUniqueInput) => ObservationPromise;
  deleteManyObservations: (
    where?: ObservationWhereInput
  ) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (
    args: { data: PersonUpdateInput; where: PersonWhereUniqueInput }
  ) => PersonPromise;
  updateManyPersons: (
    args: { data: PersonUpdateManyMutationInput; where?: PersonWhereInput }
  ) => BatchPayloadPromise;
  upsertPerson: (
    args: {
      where: PersonWhereUniqueInput;
      create: PersonCreateInput;
      update: PersonUpdateInput;
    }
  ) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createProposal: (data: ProposalCreateInput) => ProposalPromise;
  updateProposal: (
    args: { data: ProposalUpdateInput; where: ProposalWhereUniqueInput }
  ) => ProposalPromise;
  updateManyProposals: (
    args: { data: ProposalUpdateManyMutationInput; where?: ProposalWhereInput }
  ) => BatchPayloadPromise;
  upsertProposal: (
    args: {
      where: ProposalWhereUniqueInput;
      create: ProposalCreateInput;
      update: ProposalUpdateInput;
    }
  ) => ProposalPromise;
  deleteProposal: (where: ProposalWhereUniqueInput) => ProposalPromise;
  deleteManyProposals: (where?: ProposalWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  dataFile: (
    where?: DataFileSubscriptionWhereInput
  ) => DataFileSubscriptionPayloadSubscription;
  dataRequest: (
    where?: DataRequestSubscriptionWhereInput
  ) => DataRequestSubscriptionPayloadSubscription;
  dataRequestPart: (
    where?: DataRequestPartSubscriptionWhereInput
  ) => DataRequestPartSubscriptionPayloadSubscription;
  header: (
    where?: HeaderSubscriptionWhereInput
  ) => HeaderSubscriptionPayloadSubscription;
  observation: (
    where?: ObservationSubscriptionWhereInput
  ) => ObservationSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  proposal: (
    where?: ProposalSubscriptionWhereInput
  ) => ProposalSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DataRequestPartOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "statusReason_ASC"
  | "statusReason_DESC"
  | "uri_ASC"
  | "uri_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ObservationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "telescope_ASC"
  | "telescope_DESC"
  | "publicFrom_ASC"
  | "publicFrom_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DataRequestStatus = "PENDING" | "FAILED" | "SUCCESSFUL";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "familyName_ASC"
  | "familyName_DESC"
  | "givenName_ASC"
  | "givenName_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "affiliation_ASC"
  | "affiliation_DESC"
  | "password_ASC"
  | "password_DESC"
  | "passwordResetToken_ASC"
  | "passwordResetToken_DESC"
  | "passwordResetTokenExpiry_ASC"
  | "passwordResetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DataFileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "available_ASC"
  | "available_DESC"
  | "name_ASC"
  | "name_DESC"
  | "fitsHeadersURI_ASC"
  | "fitsHeadersURI_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "category_ASC"
  | "category_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Telescope = "LESEDI" | "SAAO_1_9" | "SALT";

export type Role = "ADMIN";

export type DataCategory =
  | "ACQUISITION"
  | "ARC"
  | "BIAS"
  | "FLAT"
  | "STANDARD"
  | "METADATA"
  | "SCIENCE";

export type ProposalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "title_ASC"
  | "title_DESC"
  | "abstract_ASC"
  | "abstract_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DataRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "madeAt_ASC"
  | "madeAt_DESC"
  | "uri_ASC"
  | "uri_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HeaderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "givenName_ASC"
  | "givenName_DESC"
  | "familyName_ASC"
  | "familyName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface ProposalUpdateWithoutObservationsDataInput {
  code?: String;
  title?: String;
  abstract?: String;
  principalInvestigator?: PersonUpdateOneRequiredInput;
}

export type DataFileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DataFileCreatepreviewsInput {
  set?: String[] | String;
}

export interface DataRequestPartUpdateManyDataInput {
  status?: DataRequestStatus;
  statusReason?: String;
  uri?: String;
}

export interface ObservationCreateOneWithoutDataFilesInput {
  create?: ObservationCreateWithoutDataFilesInput;
  connect?: ObservationWhereUniqueInput;
}

export interface ObservationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  telescope?: Telescope;
  telescope_not?: Telescope;
  telescope_in?: Telescope[] | Telescope;
  telescope_not_in?: Telescope[] | Telescope;
  proposal?: ProposalWhereInput;
  dataFiles_every?: DataFileWhereInput;
  dataFiles_some?: DataFileWhereInput;
  dataFiles_none?: DataFileWhereInput;
  publicFrom?: DateTimeInput;
  publicFrom_not?: DateTimeInput;
  publicFrom_in?: DateTimeInput[] | DateTimeInput;
  publicFrom_not_in?: DateTimeInput[] | DateTimeInput;
  publicFrom_lt?: DateTimeInput;
  publicFrom_lte?: DateTimeInput;
  publicFrom_gt?: DateTimeInput;
  publicFrom_gte?: DateTimeInput;
  AND?: ObservationWhereInput[] | ObservationWhereInput;
  OR?: ObservationWhereInput[] | ObservationWhereInput;
  NOT?: ObservationWhereInput[] | ObservationWhereInput;
}

export interface ObservationCreateWithoutDataFilesInput {
  id?: ID_Input;
  name: String;
  startTime: DateTimeInput;
  telescope: Telescope;
  proposal?: ProposalCreateOneWithoutObservationsInput;
  publicFrom: DateTimeInput;
}

export interface DataFileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  available?: Boolean;
  available_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  fitsHeadersURI?: String;
  fitsHeadersURI_not?: String;
  fitsHeadersURI_in?: String[] | String;
  fitsHeadersURI_not_in?: String[] | String;
  fitsHeadersURI_lt?: String;
  fitsHeadersURI_lte?: String;
  fitsHeadersURI_gt?: String;
  fitsHeadersURI_gte?: String;
  fitsHeadersURI_contains?: String;
  fitsHeadersURI_not_contains?: String;
  fitsHeadersURI_starts_with?: String;
  fitsHeadersURI_not_starts_with?: String;
  fitsHeadersURI_ends_with?: String;
  fitsHeadersURI_not_ends_with?: String;
  headers_every?: HeaderWhereInput;
  headers_some?: HeaderWhereInput;
  headers_none?: HeaderWhereInput;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  category?: DataCategory;
  category_not?: DataCategory;
  category_in?: DataCategory[] | DataCategory;
  category_not_in?: DataCategory[] | DataCategory;
  observation?: ObservationWhereInput;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  AND?: DataFileWhereInput[] | DataFileWhereInput;
  OR?: DataFileWhereInput[] | DataFileWhereInput;
  NOT?: DataFileWhereInput[] | DataFileWhereInput;
}

export interface ProposalCreateOneWithoutObservationsInput {
  create?: ProposalCreateWithoutObservationsInput;
  connect?: ProposalWhereUniqueInput;
}

export interface ProposalSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProposalWhereInput;
  AND?: ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput;
  OR?: ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput;
  NOT?: ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput;
}

export interface ProposalCreateWithoutObservationsInput {
  id?: ID_Input;
  code: String;
  title: String;
  abstract: String;
  principalInvestigator: PersonCreateOneInput;
}

export interface ObservationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ObservationWhereInput;
  AND?: ObservationSubscriptionWhereInput[] | ObservationSubscriptionWhereInput;
  OR?: ObservationSubscriptionWhereInput[] | ObservationSubscriptionWhereInput;
  NOT?: ObservationSubscriptionWhereInput[] | ObservationSubscriptionWhereInput;
}

export interface PersonCreateOneInput {
  create?: PersonCreateInput;
  connect?: PersonWhereUniqueInput;
}

export interface DataRequestPartSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DataRequestPartWhereInput;
  AND?:
    | DataRequestPartSubscriptionWhereInput[]
    | DataRequestPartSubscriptionWhereInput;
  OR?:
    | DataRequestPartSubscriptionWhereInput[]
    | DataRequestPartSubscriptionWhereInput;
  NOT?:
    | DataRequestPartSubscriptionWhereInput[]
    | DataRequestPartSubscriptionWhereInput;
}

export interface PersonCreateInput {
  id?: ID_Input;
  givenName: String;
  familyName: String;
}

export interface DataRequestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DataRequestWhereInput;
  AND?: DataRequestSubscriptionWhereInput[] | DataRequestSubscriptionWhereInput;
  OR?: DataRequestSubscriptionWhereInput[] | DataRequestSubscriptionWhereInput;
  NOT?: DataRequestSubscriptionWhereInput[] | DataRequestSubscriptionWhereInput;
}

export interface DataFileUpdateInput {
  available?: Boolean;
  name?: String;
  fitsHeadersURI?: String;
  headers?: HeaderUpdateManyInput;
  previews?: DataFileUpdatepreviewsInput;
  startTime?: DateTimeInput;
  category?: DataCategory;
  observation?: ObservationUpdateOneWithoutDataFilesInput;
  size?: Int;
}

export interface UserUpdateManyMutationInput {
  familyName?: String;
  givenName?: String;
  username?: String;
  email?: String;
  affiliation?: String;
  password?: String;
  roles?: UserUpdaterolesInput;
  passwordResetToken?: String;
  passwordResetTokenExpiry?: DateTimeInput;
}

export interface HeaderUpdateManyInput {
  create?: HeaderCreateInput[] | HeaderCreateInput;
  update?:
    | HeaderUpdateWithWhereUniqueNestedInput[]
    | HeaderUpdateWithWhereUniqueNestedInput;
  upsert?:
    | HeaderUpsertWithWhereUniqueNestedInput[]
    | HeaderUpsertWithWhereUniqueNestedInput;
  delete?: HeaderWhereUniqueInput[] | HeaderWhereUniqueInput;
  connect?: HeaderWhereUniqueInput[] | HeaderWhereUniqueInput;
  set?: HeaderWhereUniqueInput[] | HeaderWhereUniqueInput;
  disconnect?: HeaderWhereUniqueInput[] | HeaderWhereUniqueInput;
  deleteMany?: HeaderScalarWhereInput[] | HeaderScalarWhereInput;
  updateMany?:
    | HeaderUpdateManyWithWhereNestedInput[]
    | HeaderUpdateManyWithWhereNestedInput;
}

export interface UserUpdateInput {
  familyName?: String;
  givenName?: String;
  username?: String;
  email?: String;
  affiliation?: String;
  password?: String;
  roles?: UserUpdaterolesInput;
  passwordResetToken?: String;
  passwordResetTokenExpiry?: DateTimeInput;
}

export interface HeaderUpdateWithWhereUniqueNestedInput {
  where: HeaderWhereUniqueInput;
  data: HeaderUpdateDataInput;
}

export interface ObservationUpdateManyDataInput {
  name?: String;
  startTime?: DateTimeInput;
  telescope?: Telescope;
  publicFrom?: DateTimeInput;
}

export interface HeaderUpdateDataInput {
  key?: String;
  value?: String;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  familyName?: String;
  familyName_not?: String;
  familyName_in?: String[] | String;
  familyName_not_in?: String[] | String;
  familyName_lt?: String;
  familyName_lte?: String;
  familyName_gt?: String;
  familyName_gte?: String;
  familyName_contains?: String;
  familyName_not_contains?: String;
  familyName_starts_with?: String;
  familyName_not_starts_with?: String;
  familyName_ends_with?: String;
  familyName_not_ends_with?: String;
  givenName?: String;
  givenName_not?: String;
  givenName_in?: String[] | String;
  givenName_not_in?: String[] | String;
  givenName_lt?: String;
  givenName_lte?: String;
  givenName_gt?: String;
  givenName_gte?: String;
  givenName_contains?: String;
  givenName_not_contains?: String;
  givenName_starts_with?: String;
  givenName_not_starts_with?: String;
  givenName_ends_with?: String;
  givenName_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  affiliation?: String;
  affiliation_not?: String;
  affiliation_in?: String[] | String;
  affiliation_not_in?: String[] | String;
  affiliation_lt?: String;
  affiliation_lte?: String;
  affiliation_gt?: String;
  affiliation_gte?: String;
  affiliation_contains?: String;
  affiliation_not_contains?: String;
  affiliation_starts_with?: String;
  affiliation_not_starts_with?: String;
  affiliation_ends_with?: String;
  affiliation_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  passwordResetToken?: String;
  passwordResetToken_not?: String;
  passwordResetToken_in?: String[] | String;
  passwordResetToken_not_in?: String[] | String;
  passwordResetToken_lt?: String;
  passwordResetToken_lte?: String;
  passwordResetToken_gt?: String;
  passwordResetToken_gte?: String;
  passwordResetToken_contains?: String;
  passwordResetToken_not_contains?: String;
  passwordResetToken_starts_with?: String;
  passwordResetToken_not_starts_with?: String;
  passwordResetToken_ends_with?: String;
  passwordResetToken_not_ends_with?: String;
  passwordResetTokenExpiry?: DateTimeInput;
  passwordResetTokenExpiry_not?: DateTimeInput;
  passwordResetTokenExpiry_in?: DateTimeInput[] | DateTimeInput;
  passwordResetTokenExpiry_not_in?: DateTimeInput[] | DateTimeInput;
  passwordResetTokenExpiry_lt?: DateTimeInput;
  passwordResetTokenExpiry_lte?: DateTimeInput;
  passwordResetTokenExpiry_gt?: DateTimeInput;
  passwordResetTokenExpiry_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface HeaderUpsertWithWhereUniqueNestedInput {
  where: HeaderWhereUniqueInput;
  update: HeaderUpdateDataInput;
  create: HeaderCreateInput;
}

export interface ObservationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  telescope?: Telescope;
  telescope_not?: Telescope;
  telescope_in?: Telescope[] | Telescope;
  telescope_not_in?: Telescope[] | Telescope;
  publicFrom?: DateTimeInput;
  publicFrom_not?: DateTimeInput;
  publicFrom_in?: DateTimeInput[] | DateTimeInput;
  publicFrom_not_in?: DateTimeInput[] | DateTimeInput;
  publicFrom_lt?: DateTimeInput;
  publicFrom_lte?: DateTimeInput;
  publicFrom_gt?: DateTimeInput;
  publicFrom_gte?: DateTimeInput;
  AND?: ObservationScalarWhereInput[] | ObservationScalarWhereInput;
  OR?: ObservationScalarWhereInput[] | ObservationScalarWhereInput;
  NOT?: ObservationScalarWhereInput[] | ObservationScalarWhereInput;
}

export interface HeaderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: HeaderScalarWhereInput[] | HeaderScalarWhereInput;
  OR?: HeaderScalarWhereInput[] | HeaderScalarWhereInput;
  NOT?: HeaderScalarWhereInput[] | HeaderScalarWhereInput;
}

export interface ObservationUpdateWithoutProposalDataInput {
  name?: String;
  startTime?: DateTimeInput;
  telescope?: Telescope;
  dataFiles?: DataFileUpdateManyWithoutObservationInput;
  publicFrom?: DateTimeInput;
}

export interface HeaderUpdateManyWithWhereNestedInput {
  where: HeaderScalarWhereInput;
  data: HeaderUpdateManyDataInput;
}

export interface ObservationUpdateWithWhereUniqueWithoutProposalInput {
  where: ObservationWhereUniqueInput;
  data: ObservationUpdateWithoutProposalDataInput;
}

export interface HeaderUpdateManyDataInput {
  key?: String;
  value?: String;
}

export interface ProposalUpdateInput {
  code?: String;
  title?: String;
  abstract?: String;
  principalInvestigator?: PersonUpdateOneRequiredInput;
  observations?: ObservationUpdateManyWithoutProposalInput;
}

export interface DataFileUpdatepreviewsInput {
  set?: String[] | String;
}

export interface ObservationCreateWithoutProposalInput {
  id?: ID_Input;
  name: String;
  startTime: DateTimeInput;
  telescope: Telescope;
  dataFiles?: DataFileCreateManyWithoutObservationInput;
  publicFrom: DateTimeInput;
}

export interface ObservationUpdateOneWithoutDataFilesInput {
  create?: ObservationCreateWithoutDataFilesInput;
  update?: ObservationUpdateWithoutDataFilesDataInput;
  upsert?: ObservationUpsertWithoutDataFilesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ObservationWhereUniqueInput;
}

export interface ProposalCreateInput {
  id?: ID_Input;
  code: String;
  title: String;
  abstract: String;
  principalInvestigator: PersonCreateOneInput;
  observations?: ObservationCreateManyWithoutProposalInput;
}

export interface ObservationUpdateWithoutDataFilesDataInput {
  name?: String;
  startTime?: DateTimeInput;
  telescope?: Telescope;
  proposal?: ProposalUpdateOneWithoutObservationsInput;
  publicFrom?: DateTimeInput;
}

export interface PersonUpdateManyMutationInput {
  givenName?: String;
  familyName?: String;
}

export interface ProposalUpdateOneWithoutObservationsInput {
  create?: ProposalCreateWithoutObservationsInput;
  update?: ProposalUpdateWithoutObservationsDataInput;
  upsert?: ProposalUpsertWithoutObservationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProposalWhereUniqueInput;
}

export interface ObservationUpdateManyMutationInput {
  name?: String;
  startTime?: DateTimeInput;
  telescope?: Telescope;
  publicFrom?: DateTimeInput;
}

export interface DataRequestPartUpdateInput {
  dataFiles?: DataFileUpdateManyInput;
  status?: DataRequestStatus;
  statusReason?: String;
  uri?: String;
}

export interface HeaderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: HeaderWhereInput[] | HeaderWhereInput;
  OR?: HeaderWhereInput[] | HeaderWhereInput;
  NOT?: HeaderWhereInput[] | HeaderWhereInput;
}

export interface PersonUpdateOneRequiredInput {
  create?: PersonCreateInput;
  update?: PersonUpdateDataInput;
  upsert?: PersonUpsertNestedInput;
  connect?: PersonWhereUniqueInput;
}

export interface DataFileUpdateWithoutObservationDataInput {
  available?: Boolean;
  name?: String;
  fitsHeadersURI?: String;
  headers?: HeaderUpdateManyInput;
  previews?: DataFileUpdatepreviewsInput;
  startTime?: DateTimeInput;
  category?: DataCategory;
  size?: Int;
}

export interface PersonUpdateDataInput {
  givenName?: String;
  familyName?: String;
}

export type ProposalWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PersonUpsertNestedInput {
  update: PersonUpdateDataInput;
  create: PersonCreateInput;
}

export interface ObservationUpdateInput {
  name?: String;
  startTime?: DateTimeInput;
  telescope?: Telescope;
  proposal?: ProposalUpdateOneWithoutObservationsInput;
  dataFiles?: DataFileUpdateManyWithoutObservationInput;
  publicFrom?: DateTimeInput;
}

export interface ProposalUpsertWithoutObservationsInput {
  update: ProposalUpdateWithoutObservationsDataInput;
  create: ProposalCreateWithoutObservationsInput;
}

export interface DataFileCreateManyWithoutObservationInput {
  create?:
    | DataFileCreateWithoutObservationInput[]
    | DataFileCreateWithoutObservationInput;
  connect?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
}

export interface ObservationUpsertWithoutDataFilesInput {
  update: ObservationUpdateWithoutDataFilesDataInput;
  create: ObservationCreateWithoutDataFilesInput;
}

export interface ObservationCreateInput {
  id?: ID_Input;
  name: String;
  startTime: DateTimeInput;
  telescope: Telescope;
  proposal?: ProposalCreateOneWithoutObservationsInput;
  dataFiles?: DataFileCreateManyWithoutObservationInput;
  publicFrom: DateTimeInput;
}

export interface DataFileUpdateManyMutationInput {
  available?: Boolean;
  name?: String;
  fitsHeadersURI?: String;
  previews?: DataFileUpdatepreviewsInput;
  startTime?: DateTimeInput;
  category?: DataCategory;
  size?: Int;
}

export interface HeaderUpdateInput {
  key?: String;
  value?: String;
}

export interface DataRequestUpdateManyMutationInput {
  madeAt?: DateTimeInput;
  uri?: String;
}

export interface HeaderCreateManyInput {
  create?: HeaderCreateInput[] | HeaderCreateInput;
  connect?: HeaderWhereUniqueInput[] | HeaderWhereUniqueInput;
}

export interface ProposalWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  abstract?: String;
  abstract_not?: String;
  abstract_in?: String[] | String;
  abstract_not_in?: String[] | String;
  abstract_lt?: String;
  abstract_lte?: String;
  abstract_gt?: String;
  abstract_gte?: String;
  abstract_contains?: String;
  abstract_not_contains?: String;
  abstract_starts_with?: String;
  abstract_not_starts_with?: String;
  abstract_ends_with?: String;
  abstract_not_ends_with?: String;
  principalInvestigator?: PersonWhereInput;
  observations_every?: ObservationWhereInput;
  observations_some?: ObservationWhereInput;
  observations_none?: ObservationWhereInput;
  AND?: ProposalWhereInput[] | ProposalWhereInput;
  OR?: ProposalWhereInput[] | ProposalWhereInput;
  NOT?: ProposalWhereInput[] | ProposalWhereInput;
}

export interface PersonWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  givenName?: String;
  givenName_not?: String;
  givenName_in?: String[] | String;
  givenName_not_in?: String[] | String;
  givenName_lt?: String;
  givenName_lte?: String;
  givenName_gt?: String;
  givenName_gte?: String;
  givenName_contains?: String;
  givenName_not_contains?: String;
  givenName_starts_with?: String;
  givenName_not_starts_with?: String;
  givenName_ends_with?: String;
  givenName_not_ends_with?: String;
  familyName?: String;
  familyName_not?: String;
  familyName_in?: String[] | String;
  familyName_not_in?: String[] | String;
  familyName_lt?: String;
  familyName_lte?: String;
  familyName_gt?: String;
  familyName_gte?: String;
  familyName_contains?: String;
  familyName_not_contains?: String;
  familyName_starts_with?: String;
  familyName_not_starts_with?: String;
  familyName_ends_with?: String;
  familyName_not_ends_with?: String;
  AND?: PersonWhereInput[] | PersonWhereInput;
  OR?: PersonWhereInput[] | PersonWhereInput;
  NOT?: PersonWhereInput[] | PersonWhereInput;
}

export interface DataRequestCreateInput {
  id?: ID_Input;
  user: UserCreateOneInput;
  madeAt: DateTimeInput;
  parts?: DataRequestPartCreateManyInput;
  uri?: String;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PersonWhereInput;
  AND?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  OR?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  NOT?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export type DataRequestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateInput {
  id?: ID_Input;
  familyName: String;
  givenName: String;
  username: String;
  email: String;
  affiliation: String;
  password: String;
  roles?: UserCreaterolesInput;
  passwordResetToken?: String;
  passwordResetTokenExpiry?: DateTimeInput;
}

export interface DataRequestPartWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  dataFiles_every?: DataFileWhereInput;
  dataFiles_some?: DataFileWhereInput;
  dataFiles_none?: DataFileWhereInput;
  status?: DataRequestStatus;
  status_not?: DataRequestStatus;
  status_in?: DataRequestStatus[] | DataRequestStatus;
  status_not_in?: DataRequestStatus[] | DataRequestStatus;
  statusReason?: String;
  statusReason_not?: String;
  statusReason_in?: String[] | String;
  statusReason_not_in?: String[] | String;
  statusReason_lt?: String;
  statusReason_lte?: String;
  statusReason_gt?: String;
  statusReason_gte?: String;
  statusReason_contains?: String;
  statusReason_not_contains?: String;
  statusReason_starts_with?: String;
  statusReason_not_starts_with?: String;
  statusReason_ends_with?: String;
  statusReason_not_ends_with?: String;
  uri?: String;
  uri_not?: String;
  uri_in?: String[] | String;
  uri_not_in?: String[] | String;
  uri_lt?: String;
  uri_lte?: String;
  uri_gt?: String;
  uri_gte?: String;
  uri_contains?: String;
  uri_not_contains?: String;
  uri_starts_with?: String;
  uri_not_starts_with?: String;
  uri_ends_with?: String;
  uri_not_ends_with?: String;
  AND?: DataRequestPartWhereInput[] | DataRequestPartWhereInput;
  OR?: DataRequestPartWhereInput[] | DataRequestPartWhereInput;
  NOT?: DataRequestPartWhereInput[] | DataRequestPartWhereInput;
}

export interface UserCreaterolesInput {
  set?: Role[] | Role;
}

export interface DataRequestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  madeAt?: DateTimeInput;
  madeAt_not?: DateTimeInput;
  madeAt_in?: DateTimeInput[] | DateTimeInput;
  madeAt_not_in?: DateTimeInput[] | DateTimeInput;
  madeAt_lt?: DateTimeInput;
  madeAt_lte?: DateTimeInput;
  madeAt_gt?: DateTimeInput;
  madeAt_gte?: DateTimeInput;
  parts_every?: DataRequestPartWhereInput;
  parts_some?: DataRequestPartWhereInput;
  parts_none?: DataRequestPartWhereInput;
  uri?: String;
  uri_not?: String;
  uri_in?: String[] | String;
  uri_not_in?: String[] | String;
  uri_lt?: String;
  uri_lte?: String;
  uri_gt?: String;
  uri_gte?: String;
  uri_contains?: String;
  uri_not_contains?: String;
  uri_starts_with?: String;
  uri_not_starts_with?: String;
  uri_ends_with?: String;
  uri_not_ends_with?: String;
  AND?: DataRequestWhereInput[] | DataRequestWhereInput;
  OR?: DataRequestWhereInput[] | DataRequestWhereInput;
  NOT?: DataRequestWhereInput[] | DataRequestWhereInput;
}

export interface DataRequestPartCreateManyInput {
  create?: DataRequestPartCreateInput[] | DataRequestPartCreateInput;
  connect?: DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput;
}

export interface ObservationUpsertWithWhereUniqueWithoutProposalInput {
  where: ObservationWhereUniqueInput;
  update: ObservationUpdateWithoutProposalDataInput;
  create: ObservationCreateWithoutProposalInput;
}

export interface DataRequestPartCreateInput {
  id?: ID_Input;
  dataFiles?: DataFileCreateManyInput;
  status?: DataRequestStatus;
  statusReason?: String;
  uri?: String;
}

export interface ObservationUpdateManyWithoutProposalInput {
  create?:
    | ObservationCreateWithoutProposalInput[]
    | ObservationCreateWithoutProposalInput;
  delete?: ObservationWhereUniqueInput[] | ObservationWhereUniqueInput;
  connect?: ObservationWhereUniqueInput[] | ObservationWhereUniqueInput;
  set?: ObservationWhereUniqueInput[] | ObservationWhereUniqueInput;
  disconnect?: ObservationWhereUniqueInput[] | ObservationWhereUniqueInput;
  update?:
    | ObservationUpdateWithWhereUniqueWithoutProposalInput[]
    | ObservationUpdateWithWhereUniqueWithoutProposalInput;
  upsert?:
    | ObservationUpsertWithWhereUniqueWithoutProposalInput[]
    | ObservationUpsertWithWhereUniqueWithoutProposalInput;
  deleteMany?: ObservationScalarWhereInput[] | ObservationScalarWhereInput;
  updateMany?:
    | ObservationUpdateManyWithWhereNestedInput[]
    | ObservationUpdateManyWithWhereNestedInput;
}

export interface DataFileCreateManyInput {
  create?: DataFileCreateInput[] | DataFileCreateInput;
  connect?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
}

export interface ObservationCreateManyWithoutProposalInput {
  create?:
    | ObservationCreateWithoutProposalInput[]
    | ObservationCreateWithoutProposalInput;
  connect?: ObservationWhereUniqueInput[] | ObservationWhereUniqueInput;
}

export interface DataRequestUpdateInput {
  user?: UserUpdateOneRequiredInput;
  madeAt?: DateTimeInput;
  parts?: DataRequestPartUpdateManyInput;
  uri?: String;
}

export interface PersonUpdateInput {
  givenName?: String;
  familyName?: String;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface DataFileUpsertWithWhereUniqueWithoutObservationInput {
  where: DataFileWhereUniqueInput;
  update: DataFileUpdateWithoutObservationDataInput;
  create: DataFileCreateWithoutObservationInput;
}

export interface UserUpdateDataInput {
  familyName?: String;
  givenName?: String;
  username?: String;
  email?: String;
  affiliation?: String;
  password?: String;
  roles?: UserUpdaterolesInput;
  passwordResetToken?: String;
  passwordResetTokenExpiry?: DateTimeInput;
}

export interface DataFileUpdateManyWithoutObservationInput {
  create?:
    | DataFileCreateWithoutObservationInput[]
    | DataFileCreateWithoutObservationInput;
  delete?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
  connect?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
  set?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
  disconnect?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
  update?:
    | DataFileUpdateWithWhereUniqueWithoutObservationInput[]
    | DataFileUpdateWithWhereUniqueWithoutObservationInput;
  upsert?:
    | DataFileUpsertWithWhereUniqueWithoutObservationInput[]
    | DataFileUpsertWithWhereUniqueWithoutObservationInput;
  deleteMany?: DataFileScalarWhereInput[] | DataFileScalarWhereInput;
  updateMany?:
    | DataFileUpdateManyWithWhereNestedInput[]
    | DataFileUpdateManyWithWhereNestedInput;
}

export interface UserUpdaterolesInput {
  set?: Role[] | Role;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
  email?: String;
  passwordResetToken?: String;
}>;

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface DataRequestPartUpdateManyMutationInput {
  status?: DataRequestStatus;
  statusReason?: String;
  uri?: String;
}

export interface DataRequestPartUpdateManyInput {
  create?: DataRequestPartCreateInput[] | DataRequestPartCreateInput;
  update?:
    | DataRequestPartUpdateWithWhereUniqueNestedInput[]
    | DataRequestPartUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DataRequestPartUpsertWithWhereUniqueNestedInput[]
    | DataRequestPartUpsertWithWhereUniqueNestedInput;
  delete?: DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput;
  connect?: DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput;
  set?: DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput;
  disconnect?:
    | DataRequestPartWhereUniqueInput[]
    | DataRequestPartWhereUniqueInput;
  deleteMany?:
    | DataRequestPartScalarWhereInput[]
    | DataRequestPartScalarWhereInput;
  updateMany?:
    | DataRequestPartUpdateManyWithWhereNestedInput[]
    | DataRequestPartUpdateManyWithWhereNestedInput;
}

export interface HeaderCreateInput {
  id?: ID_Input;
  key: String;
  value?: String;
}

export interface DataRequestPartUpdateWithWhereUniqueNestedInput {
  where: DataRequestPartWhereUniqueInput;
  data: DataRequestPartUpdateDataInput;
}

export interface HeaderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HeaderWhereInput;
  AND?: HeaderSubscriptionWhereInput[] | HeaderSubscriptionWhereInput;
  OR?: HeaderSubscriptionWhereInput[] | HeaderSubscriptionWhereInput;
  NOT?: HeaderSubscriptionWhereInput[] | HeaderSubscriptionWhereInput;
}

export interface DataRequestPartUpdateDataInput {
  dataFiles?: DataFileUpdateManyInput;
  status?: DataRequestStatus;
  statusReason?: String;
  uri?: String;
}

export interface ProposalUpdateManyMutationInput {
  code?: String;
  title?: String;
  abstract?: String;
}

export interface DataFileUpdateManyInput {
  create?: DataFileCreateInput[] | DataFileCreateInput;
  update?:
    | DataFileUpdateWithWhereUniqueNestedInput[]
    | DataFileUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DataFileUpsertWithWhereUniqueNestedInput[]
    | DataFileUpsertWithWhereUniqueNestedInput;
  delete?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
  connect?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
  set?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
  disconnect?: DataFileWhereUniqueInput[] | DataFileWhereUniqueInput;
  deleteMany?: DataFileScalarWhereInput[] | DataFileScalarWhereInput;
  updateMany?:
    | DataFileUpdateManyWithWhereNestedInput[]
    | DataFileUpdateManyWithWhereNestedInput;
}

export type DataRequestPartWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DataFileUpdateWithWhereUniqueNestedInput {
  where: DataFileWhereUniqueInput;
  data: DataFileUpdateDataInput;
}

export type ObservationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DataFileUpdateDataInput {
  available?: Boolean;
  name?: String;
  fitsHeadersURI?: String;
  headers?: HeaderUpdateManyInput;
  previews?: DataFileUpdatepreviewsInput;
  startTime?: DateTimeInput;
  category?: DataCategory;
  observation?: ObservationUpdateOneWithoutDataFilesInput;
  size?: Int;
}

export interface DataFileUpdateWithWhereUniqueWithoutObservationInput {
  where: DataFileWhereUniqueInput;
  data: DataFileUpdateWithoutObservationDataInput;
}

export interface DataFileUpsertWithWhereUniqueNestedInput {
  where: DataFileWhereUniqueInput;
  update: DataFileUpdateDataInput;
  create: DataFileCreateInput;
}

export interface HeaderUpdateManyMutationInput {
  key?: String;
  value?: String;
}

export interface DataFileScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  available?: Boolean;
  available_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  fitsHeadersURI?: String;
  fitsHeadersURI_not?: String;
  fitsHeadersURI_in?: String[] | String;
  fitsHeadersURI_not_in?: String[] | String;
  fitsHeadersURI_lt?: String;
  fitsHeadersURI_lte?: String;
  fitsHeadersURI_gt?: String;
  fitsHeadersURI_gte?: String;
  fitsHeadersURI_contains?: String;
  fitsHeadersURI_not_contains?: String;
  fitsHeadersURI_starts_with?: String;
  fitsHeadersURI_not_starts_with?: String;
  fitsHeadersURI_ends_with?: String;
  fitsHeadersURI_not_ends_with?: String;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  category?: DataCategory;
  category_not?: DataCategory;
  category_in?: DataCategory[] | DataCategory;
  category_not_in?: DataCategory[] | DataCategory;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  AND?: DataFileScalarWhereInput[] | DataFileScalarWhereInput;
  OR?: DataFileScalarWhereInput[] | DataFileScalarWhereInput;
  NOT?: DataFileScalarWhereInput[] | DataFileScalarWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface DataFileUpdateManyWithWhereNestedInput {
  where: DataFileScalarWhereInput;
  data: DataFileUpdateManyDataInput;
}

export interface ObservationUpdateManyWithWhereNestedInput {
  where: ObservationScalarWhereInput;
  data: ObservationUpdateManyDataInput;
}

export interface DataRequestPartUpdateManyWithWhereNestedInput {
  where: DataRequestPartScalarWhereInput;
  data: DataRequestPartUpdateManyDataInput;
}

export interface DataRequestPartScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: DataRequestStatus;
  status_not?: DataRequestStatus;
  status_in?: DataRequestStatus[] | DataRequestStatus;
  status_not_in?: DataRequestStatus[] | DataRequestStatus;
  statusReason?: String;
  statusReason_not?: String;
  statusReason_in?: String[] | String;
  statusReason_not_in?: String[] | String;
  statusReason_lt?: String;
  statusReason_lte?: String;
  statusReason_gt?: String;
  statusReason_gte?: String;
  statusReason_contains?: String;
  statusReason_not_contains?: String;
  statusReason_starts_with?: String;
  statusReason_not_starts_with?: String;
  statusReason_ends_with?: String;
  statusReason_not_ends_with?: String;
  uri?: String;
  uri_not?: String;
  uri_in?: String[] | String;
  uri_not_in?: String[] | String;
  uri_lt?: String;
  uri_lte?: String;
  uri_gt?: String;
  uri_gte?: String;
  uri_contains?: String;
  uri_not_contains?: String;
  uri_starts_with?: String;
  uri_not_starts_with?: String;
  uri_ends_with?: String;
  uri_not_ends_with?: String;
  AND?: DataRequestPartScalarWhereInput[] | DataRequestPartScalarWhereInput;
  OR?: DataRequestPartScalarWhereInput[] | DataRequestPartScalarWhereInput;
  NOT?: DataRequestPartScalarWhereInput[] | DataRequestPartScalarWhereInput;
}

export interface DataRequestPartUpsertWithWhereUniqueNestedInput {
  where: DataRequestPartWhereUniqueInput;
  update: DataRequestPartUpdateDataInput;
  create: DataRequestPartCreateInput;
}

export interface DataFileUpdateManyDataInput {
  available?: Boolean;
  name?: String;
  fitsHeadersURI?: String;
  previews?: DataFileUpdatepreviewsInput;
  startTime?: DateTimeInput;
  category?: DataCategory;
  size?: Int;
}

export type HeaderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DataFileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DataFileWhereInput;
  AND?: DataFileSubscriptionWhereInput[] | DataFileSubscriptionWhereInput;
  OR?: DataFileSubscriptionWhereInput[] | DataFileSubscriptionWhereInput;
  NOT?: DataFileSubscriptionWhereInput[] | DataFileSubscriptionWhereInput;
}

export interface DataFileCreateInput {
  id?: ID_Input;
  available?: Boolean;
  name: String;
  fitsHeadersURI?: String;
  headers?: HeaderCreateManyInput;
  previews?: DataFileCreatepreviewsInput;
  startTime?: DateTimeInput;
  category: DataCategory;
  observation?: ObservationCreateOneWithoutDataFilesInput;
  size?: Int;
}

export interface DataFileCreateWithoutObservationInput {
  id?: ID_Input;
  available?: Boolean;
  name: String;
  fitsHeadersURI?: String;
  headers?: HeaderCreateManyInput;
  previews?: DataFileCreatepreviewsInput;
  startTime?: DateTimeInput;
  category: DataCategory;
  size?: Int;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  familyName: String;
  givenName: String;
  username: String;
  email: String;
  affiliation: String;
  password: String;
  roles: Role[];
  passwordResetToken?: String;
  passwordResetTokenExpiry?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  familyName: () => Promise<String>;
  givenName: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  affiliation: () => Promise<String>;
  password: () => Promise<String>;
  roles: () => Promise<Role[]>;
  passwordResetToken: () => Promise<String>;
  passwordResetTokenExpiry: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  familyName: () => Promise<AsyncIterator<String>>;
  givenName: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  affiliation: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<Role[]>>;
  passwordResetToken: () => Promise<AsyncIterator<String>>;
  passwordResetTokenExpiry: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Header {
  id: ID_Output;
  key: String;
  value?: String;
}

export interface HeaderPromise extends Promise<Header>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface HeaderSubscription
  extends Promise<AsyncIterator<Header>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DataRequestPart {
  id: ID_Output;
  status: DataRequestStatus;
  statusReason: String;
  uri?: String;
}

export interface DataRequestPartPromise
  extends Promise<DataRequestPart>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dataFiles: <T = FragmentableArray<DataFile>>(
    args?: {
      where?: DataFileWhereInput;
      orderBy?: DataFileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  status: () => Promise<DataRequestStatus>;
  statusReason: () => Promise<String>;
  uri: () => Promise<String>;
}

export interface DataRequestPartSubscription
  extends Promise<AsyncIterator<DataRequestPart>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dataFiles: <T = Promise<AsyncIterator<DataFileSubscription>>>(
    args?: {
      where?: DataFileWhereInput;
      orderBy?: DataFileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  status: () => Promise<AsyncIterator<DataRequestStatus>>;
  statusReason: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface Proposal {
  id: ID_Output;
  code: String;
  title: String;
  abstract: String;
}

export interface ProposalPromise extends Promise<Proposal>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  title: () => Promise<String>;
  abstract: () => Promise<String>;
  principalInvestigator: <T = PersonPromise>() => T;
  observations: <T = FragmentableArray<Observation>>(
    args?: {
      where?: ObservationWhereInput;
      orderBy?: ObservationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProposalSubscription
  extends Promise<AsyncIterator<Proposal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  abstract: () => Promise<AsyncIterator<String>>;
  principalInvestigator: <T = PersonSubscription>() => T;
  observations: <T = Promise<AsyncIterator<ObservationSubscription>>>(
    args?: {
      where?: ObservationWhereInput;
      orderBy?: ObservationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProposalSubscriptionPayload {
  mutation: MutationType;
  node: Proposal;
  updatedFields: String[];
  previousValues: ProposalPreviousValues;
}

export interface ProposalSubscriptionPayloadPromise
  extends Promise<ProposalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProposalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProposalPreviousValuesPromise>() => T;
}

export interface ProposalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProposalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProposalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProposalPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Observation {
  id: ID_Output;
  name: String;
  startTime: DateTimeOutput;
  telescope: Telescope;
  publicFrom: DateTimeOutput;
}

export interface ObservationPromise extends Promise<Observation>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  telescope: () => Promise<Telescope>;
  proposal: <T = ProposalPromise>() => T;
  dataFiles: <T = FragmentableArray<DataFile>>(
    args?: {
      where?: DataFileWhereInput;
      orderBy?: DataFileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  publicFrom: () => Promise<DateTimeOutput>;
}

export interface ObservationSubscription
  extends Promise<AsyncIterator<Observation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  telescope: () => Promise<AsyncIterator<Telescope>>;
  proposal: <T = ProposalSubscription>() => T;
  dataFiles: <T = Promise<AsyncIterator<DataFileSubscription>>>(
    args?: {
      where?: DataFileWhereInput;
      orderBy?: DataFileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  publicFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProposalEdge {
  node: Proposal;
  cursor: String;
}

export interface ProposalEdgePromise
  extends Promise<ProposalEdge>,
    Fragmentable {
  node: <T = ProposalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProposalEdgeSubscription
  extends Promise<AsyncIterator<ProposalEdge>>,
    Fragmentable {
  node: <T = ProposalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  familyName: String;
  givenName: String;
  username: String;
  email: String;
  affiliation: String;
  password: String;
  roles: Role[];
  passwordResetToken?: String;
  passwordResetTokenExpiry?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  familyName: () => Promise<String>;
  givenName: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  affiliation: () => Promise<String>;
  password: () => Promise<String>;
  roles: () => Promise<Role[]>;
  passwordResetToken: () => Promise<String>;
  passwordResetTokenExpiry: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  familyName: () => Promise<AsyncIterator<String>>;
  givenName: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  affiliation: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<Role[]>>;
  passwordResetToken: () => Promise<AsyncIterator<String>>;
  passwordResetTokenExpiry: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Person {
  id: ID_Output;
  givenName: String;
  familyName: String;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  id: () => Promise<ID_Output>;
  givenName: () => Promise<String>;
  familyName: () => Promise<String>;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  givenName: () => Promise<AsyncIterator<String>>;
  familyName: () => Promise<AsyncIterator<String>>;
}

export interface DataFile {
  id: ID_Output;
  available: Boolean;
  name: String;
  fitsHeadersURI?: String;
  previews: String[];
  startTime?: DateTimeOutput;
  category: DataCategory;
  size?: Int;
}

export interface DataFilePromise extends Promise<DataFile>, Fragmentable {
  id: () => Promise<ID_Output>;
  available: () => Promise<Boolean>;
  name: () => Promise<String>;
  fitsHeadersURI: () => Promise<String>;
  headers: <T = FragmentableArray<Header>>(
    args?: {
      where?: HeaderWhereInput;
      orderBy?: HeaderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  previews: () => Promise<String[]>;
  startTime: () => Promise<DateTimeOutput>;
  category: () => Promise<DataCategory>;
  observation: <T = ObservationPromise>() => T;
  size: () => Promise<Int>;
}

export interface DataFileSubscription
  extends Promise<AsyncIterator<DataFile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  fitsHeadersURI: () => Promise<AsyncIterator<String>>;
  headers: <T = Promise<AsyncIterator<HeaderSubscription>>>(
    args?: {
      where?: HeaderWhereInput;
      orderBy?: HeaderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  previews: () => Promise<AsyncIterator<String[]>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: () => Promise<AsyncIterator<DataCategory>>;
  observation: <T = ObservationSubscription>() => T;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface PersonEdge {
  node: Person;
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DataFileSubscriptionPayload {
  mutation: MutationType;
  node: DataFile;
  updatedFields: String[];
  previousValues: DataFilePreviousValues;
}

export interface DataFileSubscriptionPayloadPromise
  extends Promise<DataFileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataFilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataFilePreviousValuesPromise>() => T;
}

export interface DataFileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataFileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataFileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataFilePreviousValuesSubscription>() => T;
}

export interface AggregateObservation {
  count: Int;
}

export interface AggregateObservationPromise
  extends Promise<AggregateObservation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateObservationSubscription
  extends Promise<AsyncIterator<AggregateObservation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataFilePreviousValues {
  id: ID_Output;
  available: Boolean;
  name: String;
  fitsHeadersURI?: String;
  previews: String[];
  startTime?: DateTimeOutput;
  category: DataCategory;
  size?: Int;
}

export interface DataFilePreviousValuesPromise
  extends Promise<DataFilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  available: () => Promise<Boolean>;
  name: () => Promise<String>;
  fitsHeadersURI: () => Promise<String>;
  previews: () => Promise<String[]>;
  startTime: () => Promise<DateTimeOutput>;
  category: () => Promise<DataCategory>;
  size: () => Promise<Int>;
}

export interface DataFilePreviousValuesSubscription
  extends Promise<AsyncIterator<DataFilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  fitsHeadersURI: () => Promise<AsyncIterator<String>>;
  previews: () => Promise<AsyncIterator<String[]>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: () => Promise<AsyncIterator<DataCategory>>;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface ObservationConnection {
  pageInfo: PageInfo;
  edges: ObservationEdge[];
}

export interface ObservationConnectionPromise
  extends Promise<ObservationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ObservationEdge>>() => T;
  aggregate: <T = AggregateObservationPromise>() => T;
}

export interface ObservationConnectionSubscription
  extends Promise<AsyncIterator<ObservationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ObservationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateObservationSubscription>() => T;
}

export interface DataRequest {
  id: ID_Output;
  madeAt: DateTimeOutput;
  uri?: String;
}

export interface DataRequestPromise extends Promise<DataRequest>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  madeAt: () => Promise<DateTimeOutput>;
  parts: <T = FragmentableArray<DataRequestPart>>(
    args?: {
      where?: DataRequestPartWhereInput;
      orderBy?: DataRequestPartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  uri: () => Promise<String>;
}

export interface DataRequestSubscription
  extends Promise<AsyncIterator<DataRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  madeAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  parts: <T = Promise<AsyncIterator<DataRequestPartSubscription>>>(
    args?: {
      where?: DataRequestPartWhereInput;
      orderBy?: DataRequestPartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface HeaderEdge {
  node: Header;
  cursor: String;
}

export interface HeaderEdgePromise extends Promise<HeaderEdge>, Fragmentable {
  node: <T = HeaderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HeaderEdgeSubscription
  extends Promise<AsyncIterator<HeaderEdge>>,
    Fragmentable {
  node: <T = HeaderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestSubscriptionPayload {
  mutation: MutationType;
  node: DataRequest;
  updatedFields: String[];
  previousValues: DataRequestPreviousValues;
}

export interface DataRequestSubscriptionPayloadPromise
  extends Promise<DataRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataRequestPreviousValuesPromise>() => T;
}

export interface DataRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataRequestPreviousValuesSubscription>() => T;
}

export interface AggregateDataRequestPart {
  count: Int;
}

export interface AggregateDataRequestPartPromise
  extends Promise<AggregateDataRequestPart>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataRequestPartSubscription
  extends Promise<AsyncIterator<AggregateDataRequestPart>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataRequestPreviousValues {
  id: ID_Output;
  madeAt: DateTimeOutput;
  uri?: String;
}

export interface DataRequestPreviousValuesPromise
  extends Promise<DataRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  madeAt: () => Promise<DateTimeOutput>;
  uri: () => Promise<String>;
}

export interface DataRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<DataRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  madeAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestPartConnection {
  pageInfo: PageInfo;
  edges: DataRequestPartEdge[];
}

export interface DataRequestPartConnectionPromise
  extends Promise<DataRequestPartConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataRequestPartEdge>>() => T;
  aggregate: <T = AggregateDataRequestPartPromise>() => T;
}

export interface DataRequestPartConnectionSubscription
  extends Promise<AsyncIterator<DataRequestPartConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataRequestPartEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataRequestPartSubscription>() => T;
}

export interface AggregateDataFile {
  count: Int;
}

export interface AggregateDataFilePromise
  extends Promise<AggregateDataFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataFileSubscription
  extends Promise<AsyncIterator<AggregateDataFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataRequestEdge {
  node: DataRequest;
  cursor: String;
}

export interface DataRequestEdgePromise
  extends Promise<DataRequestEdge>,
    Fragmentable {
  node: <T = DataRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataRequestEdgeSubscription
  extends Promise<AsyncIterator<DataRequestEdge>>,
    Fragmentable {
  node: <T = DataRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestPartSubscriptionPayload {
  mutation: MutationType;
  node: DataRequestPart;
  updatedFields: String[];
  previousValues: DataRequestPartPreviousValues;
}

export interface DataRequestPartSubscriptionPayloadPromise
  extends Promise<DataRequestPartSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataRequestPartPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataRequestPartPreviousValuesPromise>() => T;
}

export interface DataRequestPartSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataRequestPartSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataRequestPartSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataRequestPartPreviousValuesSubscription>() => T;
}

export interface ProposalPreviousValues {
  id: ID_Output;
  code: String;
  title: String;
  abstract: String;
}

export interface ProposalPreviousValuesPromise
  extends Promise<ProposalPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  title: () => Promise<String>;
  abstract: () => Promise<String>;
}

export interface ProposalPreviousValuesSubscription
  extends Promise<AsyncIterator<ProposalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  abstract: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestPartPreviousValues {
  id: ID_Output;
  status: DataRequestStatus;
  statusReason: String;
  uri?: String;
}

export interface DataRequestPartPreviousValuesPromise
  extends Promise<DataRequestPartPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<DataRequestStatus>;
  statusReason: () => Promise<String>;
  uri: () => Promise<String>;
}

export interface DataRequestPartPreviousValuesSubscription
  extends Promise<AsyncIterator<DataRequestPartPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<DataRequestStatus>>;
  statusReason: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProposal {
  count: Int;
}

export interface AggregateProposalPromise
  extends Promise<AggregateProposal>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProposalSubscription
  extends Promise<AsyncIterator<AggregateProposal>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataFileEdge {
  node: DataFile;
  cursor: String;
}

export interface DataFileEdgePromise
  extends Promise<DataFileEdge>,
    Fragmentable {
  node: <T = DataFilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataFileEdgeSubscription
  extends Promise<AsyncIterator<DataFileEdge>>,
    Fragmentable {
  node: <T = DataFileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HeaderSubscriptionPayload {
  mutation: MutationType;
  node: Header;
  updatedFields: String[];
  previousValues: HeaderPreviousValues;
}

export interface HeaderSubscriptionPayloadPromise
  extends Promise<HeaderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HeaderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HeaderPreviousValuesPromise>() => T;
}

export interface HeaderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HeaderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HeaderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HeaderPreviousValuesSubscription>() => T;
}

export interface ObservationEdge {
  node: Observation;
  cursor: String;
}

export interface ObservationEdgePromise
  extends Promise<ObservationEdge>,
    Fragmentable {
  node: <T = ObservationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ObservationEdgeSubscription
  extends Promise<AsyncIterator<ObservationEdge>>,
    Fragmentable {
  node: <T = ObservationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HeaderPreviousValues {
  id: ID_Output;
  key: String;
  value?: String;
}

export interface HeaderPreviousValuesPromise
  extends Promise<HeaderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface HeaderPreviousValuesSubscription
  extends Promise<AsyncIterator<HeaderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface HeaderConnection {
  pageInfo: PageInfo;
  edges: HeaderEdge[];
}

export interface HeaderConnectionPromise
  extends Promise<HeaderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HeaderEdge>>() => T;
  aggregate: <T = AggregateHeaderPromise>() => T;
}

export interface HeaderConnectionSubscription
  extends Promise<AsyncIterator<HeaderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HeaderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHeaderSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDataRequest {
  count: Int;
}

export interface AggregateDataRequestPromise
  extends Promise<AggregateDataRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataRequestSubscription
  extends Promise<AsyncIterator<AggregateDataRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ObservationSubscriptionPayload {
  mutation: MutationType;
  node: Observation;
  updatedFields: String[];
  previousValues: ObservationPreviousValues;
}

export interface ObservationSubscriptionPayloadPromise
  extends Promise<ObservationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ObservationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ObservationPreviousValuesPromise>() => T;
}

export interface ObservationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ObservationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ObservationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ObservationPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PersonConnection {
  pageInfo: PageInfo;
  edges: PersonEdge[];
}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface PersonPreviousValues {
  id: ID_Output;
  givenName: String;
  familyName: String;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  givenName: () => Promise<String>;
  familyName: () => Promise<String>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  givenName: () => Promise<AsyncIterator<String>>;
  familyName: () => Promise<AsyncIterator<String>>;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  node: Person;
  updatedFields: String[];
  previousValues: PersonPreviousValues;
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface DataFileConnection {
  pageInfo: PageInfo;
  edges: DataFileEdge[];
}

export interface DataFileConnectionPromise
  extends Promise<DataFileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataFileEdge>>() => T;
  aggregate: <T = AggregateDataFilePromise>() => T;
}

export interface DataFileConnectionSubscription
  extends Promise<AsyncIterator<DataFileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataFileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataFileSubscription>() => T;
}

export interface ObservationPreviousValues {
  id: ID_Output;
  name: String;
  startTime: DateTimeOutput;
  telescope: Telescope;
  publicFrom: DateTimeOutput;
}

export interface ObservationPreviousValuesPromise
  extends Promise<ObservationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  telescope: () => Promise<Telescope>;
  publicFrom: () => Promise<DateTimeOutput>;
}

export interface ObservationPreviousValuesSubscription
  extends Promise<AsyncIterator<ObservationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  telescope: () => Promise<AsyncIterator<Telescope>>;
  publicFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateHeader {
  count: Int;
}

export interface AggregateHeaderPromise
  extends Promise<AggregateHeader>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHeaderSubscription
  extends Promise<AsyncIterator<AggregateHeader>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProposalConnection {
  pageInfo: PageInfo;
  edges: ProposalEdge[];
}

export interface ProposalConnectionPromise
  extends Promise<ProposalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProposalEdge>>() => T;
  aggregate: <T = AggregateProposalPromise>() => T;
}

export interface ProposalConnectionSubscription
  extends Promise<AsyncIterator<ProposalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProposalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProposalSubscription>() => T;
}

export interface DataRequestConnection {
  pageInfo: PageInfo;
  edges: DataRequestEdge[];
}

export interface DataRequestConnectionPromise
  extends Promise<DataRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataRequestEdge>>() => T;
  aggregate: <T = AggregateDataRequestPromise>() => T;
}

export interface DataRequestConnectionSubscription
  extends Promise<AsyncIterator<DataRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataRequestSubscription>() => T;
}

export interface DataRequestPartEdge {
  node: DataRequestPart;
  cursor: String;
}

export interface DataRequestPartEdgePromise
  extends Promise<DataRequestPartEdge>,
    Fragmentable {
  node: <T = DataRequestPartPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataRequestPartEdgeSubscription
  extends Promise<AsyncIterator<DataRequestPartEdge>>,
    Fragmentable {
  node: <T = DataRequestPartSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "DataRequestStatus",
    embedded: false
  },
  {
    name: "DataCategory",
    embedded: false
  },
  {
    name: "Telescope",
    embedded: false
  },
  {
    name: "Header",
    embedded: false
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "Proposal",
    embedded: false
  },
  {
    name: "Observation",
    embedded: false
  },
  {
    name: "DataFile",
    embedded: false
  },
  {
    name: "DataRequest",
    embedded: false
  },
  {
    name: "DataRequestPart",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
