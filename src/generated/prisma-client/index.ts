// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  dataFile: (where?: DataFileWhereInput) => Promise<boolean>;
  dataRequest: (where?: DataRequestWhereInput) => Promise<boolean>;
  dataRequestPart: (where?: DataRequestPartWhereInput) => Promise<boolean>;
  header: (where?: HeaderWhereInput) => Promise<boolean>;
  observation: (where?: ObservationWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  proposal: (where?: ProposalWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  dataFile: (where: DataFileWhereUniqueInput) => DataFileNullablePromise;
  dataFiles: (args?: {
    where?: DataFileWhereInput;
    orderBy?: DataFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DataFile>;
  dataFilesConnection: (args?: {
    where?: DataFileWhereInput;
    orderBy?: DataFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DataFileConnectionPromise;
  dataRequest: (
    where: DataRequestWhereUniqueInput
  ) => DataRequestNullablePromise;
  dataRequests: (args?: {
    where?: DataRequestWhereInput;
    orderBy?: DataRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DataRequest>;
  dataRequestsConnection: (args?: {
    where?: DataRequestWhereInput;
    orderBy?: DataRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DataRequestConnectionPromise;
  dataRequestPart: (
    where: DataRequestPartWhereUniqueInput
  ) => DataRequestPartNullablePromise;
  dataRequestParts: (args?: {
    where?: DataRequestPartWhereInput;
    orderBy?: DataRequestPartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DataRequestPart>;
  dataRequestPartsConnection: (args?: {
    where?: DataRequestPartWhereInput;
    orderBy?: DataRequestPartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DataRequestPartConnectionPromise;
  header: (where: HeaderWhereUniqueInput) => HeaderNullablePromise;
  headers: (args?: {
    where?: HeaderWhereInput;
    orderBy?: HeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Header>;
  headersConnection: (args?: {
    where?: HeaderWhereInput;
    orderBy?: HeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HeaderConnectionPromise;
  observation: (
    where: ObservationWhereUniqueInput
  ) => ObservationNullablePromise;
  observations: (args?: {
    where?: ObservationWhereInput;
    orderBy?: ObservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Observation>;
  observationsConnection: (args?: {
    where?: ObservationWhereInput;
    orderBy?: ObservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ObservationConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonNullablePromise;
  persons: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Person>;
  personsConnection: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PersonConnectionPromise;
  proposal: (where: ProposalWhereUniqueInput) => ProposalNullablePromise;
  proposals: (args?: {
    where?: ProposalWhereInput;
    orderBy?: ProposalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Proposal>;
  proposalsConnection: (args?: {
    where?: ProposalWhereInput;
    orderBy?: ProposalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProposalConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDataFile: (data: DataFileCreateInput) => DataFilePromise;
  updateDataFile: (args: {
    data: DataFileUpdateInput;
    where: DataFileWhereUniqueInput;
  }) => DataFilePromise;
  updateManyDataFiles: (args: {
    data: DataFileUpdateManyMutationInput;
    where?: DataFileWhereInput;
  }) => BatchPayloadPromise;
  upsertDataFile: (args: {
    where: DataFileWhereUniqueInput;
    create: DataFileCreateInput;
    update: DataFileUpdateInput;
  }) => DataFilePromise;
  deleteDataFile: (where: DataFileWhereUniqueInput) => DataFilePromise;
  deleteManyDataFiles: (where?: DataFileWhereInput) => BatchPayloadPromise;
  createDataRequest: (data: DataRequestCreateInput) => DataRequestPromise;
  updateDataRequest: (args: {
    data: DataRequestUpdateInput;
    where: DataRequestWhereUniqueInput;
  }) => DataRequestPromise;
  updateManyDataRequests: (args: {
    data: DataRequestUpdateManyMutationInput;
    where?: DataRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertDataRequest: (args: {
    where: DataRequestWhereUniqueInput;
    create: DataRequestCreateInput;
    update: DataRequestUpdateInput;
  }) => DataRequestPromise;
  deleteDataRequest: (where: DataRequestWhereUniqueInput) => DataRequestPromise;
  deleteManyDataRequests: (
    where?: DataRequestWhereInput
  ) => BatchPayloadPromise;
  createDataRequestPart: (
    data: DataRequestPartCreateInput
  ) => DataRequestPartPromise;
  updateDataRequestPart: (args: {
    data: DataRequestPartUpdateInput;
    where: DataRequestPartWhereUniqueInput;
  }) => DataRequestPartPromise;
  updateManyDataRequestParts: (args: {
    data: DataRequestPartUpdateManyMutationInput;
    where?: DataRequestPartWhereInput;
  }) => BatchPayloadPromise;
  upsertDataRequestPart: (args: {
    where: DataRequestPartWhereUniqueInput;
    create: DataRequestPartCreateInput;
    update: DataRequestPartUpdateInput;
  }) => DataRequestPartPromise;
  deleteDataRequestPart: (
    where: DataRequestPartWhereUniqueInput
  ) => DataRequestPartPromise;
  deleteManyDataRequestParts: (
    where?: DataRequestPartWhereInput
  ) => BatchPayloadPromise;
  createHeader: (data: HeaderCreateInput) => HeaderPromise;
  updateHeader: (args: {
    data: HeaderUpdateInput;
    where: HeaderWhereUniqueInput;
  }) => HeaderPromise;
  updateManyHeaders: (args: {
    data: HeaderUpdateManyMutationInput;
    where?: HeaderWhereInput;
  }) => BatchPayloadPromise;
  upsertHeader: (args: {
    where: HeaderWhereUniqueInput;
    create: HeaderCreateInput;
    update: HeaderUpdateInput;
  }) => HeaderPromise;
  deleteHeader: (where: HeaderWhereUniqueInput) => HeaderPromise;
  deleteManyHeaders: (where?: HeaderWhereInput) => BatchPayloadPromise;
  createObservation: (data: ObservationCreateInput) => ObservationPromise;
  updateObservation: (args: {
    data: ObservationUpdateInput;
    where: ObservationWhereUniqueInput;
  }) => ObservationPromise;
  updateManyObservations: (args: {
    data: ObservationUpdateManyMutationInput;
    where?: ObservationWhereInput;
  }) => BatchPayloadPromise;
  upsertObservation: (args: {
    where: ObservationWhereUniqueInput;
    create: ObservationCreateInput;
    update: ObservationUpdateInput;
  }) => ObservationPromise;
  deleteObservation: (where: ObservationWhereUniqueInput) => ObservationPromise;
  deleteManyObservations: (
    where?: ObservationWhereInput
  ) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (args: {
    data: PersonUpdateInput;
    where: PersonWhereUniqueInput;
  }) => PersonPromise;
  updateManyPersons: (args: {
    data: PersonUpdateManyMutationInput;
    where?: PersonWhereInput;
  }) => BatchPayloadPromise;
  upsertPerson: (args: {
    where: PersonWhereUniqueInput;
    create: PersonCreateInput;
    update: PersonUpdateInput;
  }) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createProposal: (data: ProposalCreateInput) => ProposalPromise;
  updateProposal: (args: {
    data: ProposalUpdateInput;
    where: ProposalWhereUniqueInput;
  }) => ProposalPromise;
  updateManyProposals: (args: {
    data: ProposalUpdateManyMutationInput;
    where?: ProposalWhereInput;
  }) => BatchPayloadPromise;
  upsertProposal: (args: {
    where: ProposalWhereUniqueInput;
    create: ProposalCreateInput;
    update: ProposalUpdateInput;
  }) => ProposalPromise;
  deleteProposal: (where: ProposalWhereUniqueInput) => ProposalPromise;
  deleteManyProposals: (where?: ProposalWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  dataFile: (
    where?: DataFileSubscriptionWhereInput
  ) => DataFileSubscriptionPayloadSubscription;
  dataRequest: (
    where?: DataRequestSubscriptionWhereInput
  ) => DataRequestSubscriptionPayloadSubscription;
  dataRequestPart: (
    where?: DataRequestPartSubscriptionWhereInput
  ) => DataRequestPartSubscriptionPayloadSubscription;
  header: (
    where?: HeaderSubscriptionWhereInput
  ) => HeaderSubscriptionPayloadSubscription;
  observation: (
    where?: ObservationSubscriptionWhereInput
  ) => ObservationSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  proposal: (
    where?: ProposalSubscriptionWhereInput
  ) => ProposalSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DataRequestPartOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "statusReason_ASC"
  | "statusReason_DESC"
  | "uri_ASC"
  | "uri_DESC";

export type ObservationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "telescope_ASC"
  | "telescope_DESC"
  | "publicFrom_ASC"
  | "publicFrom_DESC";

export type DataRequestStatus = "PENDING" | "FAILED" | "SUCCESSFUL";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "familyName_ASC"
  | "familyName_DESC"
  | "givenName_ASC"
  | "givenName_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "affiliation_ASC"
  | "affiliation_DESC"
  | "password_ASC"
  | "password_DESC"
  | "passwordResetToken_ASC"
  | "passwordResetToken_DESC"
  | "passwordResetTokenExpiry_ASC"
  | "passwordResetTokenExpiry_DESC";

export type DataFileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "available_ASC"
  | "available_DESC"
  | "name_ASC"
  | "name_DESC"
  | "fitsHeadersURI_ASC"
  | "fitsHeadersURI_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "category_ASC"
  | "category_DESC"
  | "size_ASC"
  | "size_DESC";

export type Telescope = "LESEDI" | "SAAO_1_9" | "SALT";

export type Role = "ADMIN";

export type DataCategory =
  | "ACQUISITION"
  | "ARC"
  | "BIAS"
  | "FLAT"
  | "STANDARD"
  | "METADATA"
  | "SCIENCE";

export type ProposalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "title_ASC"
  | "title_DESC"
  | "abstract_ASC"
  | "abstract_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DataRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "madeAt_ASC"
  | "madeAt_DESC"
  | "uri_ASC"
  | "uri_DESC";

export type HeaderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "value_ASC"
  | "value_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "givenName_ASC"
  | "givenName_DESC"
  | "familyName_ASC"
  | "familyName_DESC";

export interface ProposalUpdateWithoutObservationsDataInput {
  code?: Maybe<String>;
  title?: Maybe<String>;
  abstract?: Maybe<String>;
  principalInvestigator?: Maybe<PersonUpdateOneRequiredInput>;
}

export type DataFileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DataFileCreatepreviewsInput {
  set?: Maybe<String[] | String>;
}

export interface DataRequestPartUpdateManyDataInput {
  status?: Maybe<DataRequestStatus>;
  statusReason?: Maybe<String>;
  uri?: Maybe<String>;
}

export interface ObservationCreateOneWithoutDataFilesInput {
  create?: Maybe<ObservationCreateWithoutDataFilesInput>;
  connect?: Maybe<ObservationWhereUniqueInput>;
}

export interface ObservationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  telescope?: Maybe<Telescope>;
  telescope_not?: Maybe<Telescope>;
  telescope_in?: Maybe<Telescope[] | Telescope>;
  telescope_not_in?: Maybe<Telescope[] | Telescope>;
  proposal?: Maybe<ProposalWhereInput>;
  dataFiles_every?: Maybe<DataFileWhereInput>;
  dataFiles_some?: Maybe<DataFileWhereInput>;
  dataFiles_none?: Maybe<DataFileWhereInput>;
  publicFrom?: Maybe<DateTimeInput>;
  publicFrom_not?: Maybe<DateTimeInput>;
  publicFrom_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicFrom_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicFrom_lt?: Maybe<DateTimeInput>;
  publicFrom_lte?: Maybe<DateTimeInput>;
  publicFrom_gt?: Maybe<DateTimeInput>;
  publicFrom_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ObservationWhereInput[] | ObservationWhereInput>;
  OR?: Maybe<ObservationWhereInput[] | ObservationWhereInput>;
  NOT?: Maybe<ObservationWhereInput[] | ObservationWhereInput>;
}

export interface ObservationCreateWithoutDataFilesInput {
  id?: Maybe<ID_Input>;
  name: String;
  startTime: DateTimeInput;
  telescope: Telescope;
  proposal?: Maybe<ProposalCreateOneWithoutObservationsInput>;
  publicFrom: DateTimeInput;
}

export interface DataFileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  fitsHeadersURI?: Maybe<String>;
  fitsHeadersURI_not?: Maybe<String>;
  fitsHeadersURI_in?: Maybe<String[] | String>;
  fitsHeadersURI_not_in?: Maybe<String[] | String>;
  fitsHeadersURI_lt?: Maybe<String>;
  fitsHeadersURI_lte?: Maybe<String>;
  fitsHeadersURI_gt?: Maybe<String>;
  fitsHeadersURI_gte?: Maybe<String>;
  fitsHeadersURI_contains?: Maybe<String>;
  fitsHeadersURI_not_contains?: Maybe<String>;
  fitsHeadersURI_starts_with?: Maybe<String>;
  fitsHeadersURI_not_starts_with?: Maybe<String>;
  fitsHeadersURI_ends_with?: Maybe<String>;
  fitsHeadersURI_not_ends_with?: Maybe<String>;
  headers_every?: Maybe<HeaderWhereInput>;
  headers_some?: Maybe<HeaderWhereInput>;
  headers_none?: Maybe<HeaderWhereInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  category?: Maybe<DataCategory>;
  category_not?: Maybe<DataCategory>;
  category_in?: Maybe<DataCategory[] | DataCategory>;
  category_not_in?: Maybe<DataCategory[] | DataCategory>;
  observation?: Maybe<ObservationWhereInput>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  AND?: Maybe<DataFileWhereInput[] | DataFileWhereInput>;
  OR?: Maybe<DataFileWhereInput[] | DataFileWhereInput>;
  NOT?: Maybe<DataFileWhereInput[] | DataFileWhereInput>;
}

export interface ProposalCreateOneWithoutObservationsInput {
  create?: Maybe<ProposalCreateWithoutObservationsInput>;
  connect?: Maybe<ProposalWhereUniqueInput>;
}

export interface ProposalSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProposalWhereInput>;
  AND?: Maybe<
    ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput
  >;
  OR?: Maybe<ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput>;
  NOT?: Maybe<
    ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput
  >;
}

export interface ProposalCreateWithoutObservationsInput {
  id?: Maybe<ID_Input>;
  code: String;
  title: String;
  abstract: String;
  principalInvestigator: PersonCreateOneInput;
}

export interface ObservationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ObservationWhereInput>;
  AND?: Maybe<
    ObservationSubscriptionWhereInput[] | ObservationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ObservationSubscriptionWhereInput[] | ObservationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ObservationSubscriptionWhereInput[] | ObservationSubscriptionWhereInput
  >;
}

export interface PersonCreateOneInput {
  create?: Maybe<PersonCreateInput>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface DataRequestPartSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DataRequestPartWhereInput>;
  AND?: Maybe<
    | DataRequestPartSubscriptionWhereInput[]
    | DataRequestPartSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DataRequestPartSubscriptionWhereInput[]
    | DataRequestPartSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DataRequestPartSubscriptionWhereInput[]
    | DataRequestPartSubscriptionWhereInput
  >;
}

export interface PersonCreateInput {
  id?: Maybe<ID_Input>;
  givenName: String;
  familyName: String;
}

export interface DataRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DataRequestWhereInput>;
  AND?: Maybe<
    DataRequestSubscriptionWhereInput[] | DataRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    DataRequestSubscriptionWhereInput[] | DataRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DataRequestSubscriptionWhereInput[] | DataRequestSubscriptionWhereInput
  >;
}

export interface DataFileUpdateInput {
  available?: Maybe<Boolean>;
  name?: Maybe<String>;
  fitsHeadersURI?: Maybe<String>;
  headers?: Maybe<HeaderUpdateManyInput>;
  previews?: Maybe<DataFileUpdatepreviewsInput>;
  startTime?: Maybe<DateTimeInput>;
  category?: Maybe<DataCategory>;
  observation?: Maybe<ObservationUpdateOneWithoutDataFilesInput>;
  size?: Maybe<Int>;
}

export interface UserUpdateManyMutationInput {
  familyName?: Maybe<String>;
  givenName?: Maybe<String>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  affiliation?: Maybe<String>;
  password?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  passwordResetToken?: Maybe<String>;
  passwordResetTokenExpiry?: Maybe<DateTimeInput>;
}

export interface HeaderUpdateManyInput {
  create?: Maybe<HeaderCreateInput[] | HeaderCreateInput>;
  update?: Maybe<
    | HeaderUpdateWithWhereUniqueNestedInput[]
    | HeaderUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | HeaderUpsertWithWhereUniqueNestedInput[]
    | HeaderUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<HeaderWhereUniqueInput[] | HeaderWhereUniqueInput>;
  connect?: Maybe<HeaderWhereUniqueInput[] | HeaderWhereUniqueInput>;
  set?: Maybe<HeaderWhereUniqueInput[] | HeaderWhereUniqueInput>;
  disconnect?: Maybe<HeaderWhereUniqueInput[] | HeaderWhereUniqueInput>;
  deleteMany?: Maybe<HeaderScalarWhereInput[] | HeaderScalarWhereInput>;
  updateMany?: Maybe<
    | HeaderUpdateManyWithWhereNestedInput[]
    | HeaderUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateInput {
  familyName?: Maybe<String>;
  givenName?: Maybe<String>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  affiliation?: Maybe<String>;
  password?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  passwordResetToken?: Maybe<String>;
  passwordResetTokenExpiry?: Maybe<DateTimeInput>;
}

export interface HeaderUpdateWithWhereUniqueNestedInput {
  where: HeaderWhereUniqueInput;
  data: HeaderUpdateDataInput;
}

export interface ObservationUpdateManyDataInput {
  name?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  telescope?: Maybe<Telescope>;
  publicFrom?: Maybe<DateTimeInput>;
}

export interface HeaderUpdateDataInput {
  key?: Maybe<String>;
  value?: Maybe<String>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  familyName?: Maybe<String>;
  familyName_not?: Maybe<String>;
  familyName_in?: Maybe<String[] | String>;
  familyName_not_in?: Maybe<String[] | String>;
  familyName_lt?: Maybe<String>;
  familyName_lte?: Maybe<String>;
  familyName_gt?: Maybe<String>;
  familyName_gte?: Maybe<String>;
  familyName_contains?: Maybe<String>;
  familyName_not_contains?: Maybe<String>;
  familyName_starts_with?: Maybe<String>;
  familyName_not_starts_with?: Maybe<String>;
  familyName_ends_with?: Maybe<String>;
  familyName_not_ends_with?: Maybe<String>;
  givenName?: Maybe<String>;
  givenName_not?: Maybe<String>;
  givenName_in?: Maybe<String[] | String>;
  givenName_not_in?: Maybe<String[] | String>;
  givenName_lt?: Maybe<String>;
  givenName_lte?: Maybe<String>;
  givenName_gt?: Maybe<String>;
  givenName_gte?: Maybe<String>;
  givenName_contains?: Maybe<String>;
  givenName_not_contains?: Maybe<String>;
  givenName_starts_with?: Maybe<String>;
  givenName_not_starts_with?: Maybe<String>;
  givenName_ends_with?: Maybe<String>;
  givenName_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  affiliation?: Maybe<String>;
  affiliation_not?: Maybe<String>;
  affiliation_in?: Maybe<String[] | String>;
  affiliation_not_in?: Maybe<String[] | String>;
  affiliation_lt?: Maybe<String>;
  affiliation_lte?: Maybe<String>;
  affiliation_gt?: Maybe<String>;
  affiliation_gte?: Maybe<String>;
  affiliation_contains?: Maybe<String>;
  affiliation_not_contains?: Maybe<String>;
  affiliation_starts_with?: Maybe<String>;
  affiliation_not_starts_with?: Maybe<String>;
  affiliation_ends_with?: Maybe<String>;
  affiliation_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  passwordResetToken?: Maybe<String>;
  passwordResetToken_not?: Maybe<String>;
  passwordResetToken_in?: Maybe<String[] | String>;
  passwordResetToken_not_in?: Maybe<String[] | String>;
  passwordResetToken_lt?: Maybe<String>;
  passwordResetToken_lte?: Maybe<String>;
  passwordResetToken_gt?: Maybe<String>;
  passwordResetToken_gte?: Maybe<String>;
  passwordResetToken_contains?: Maybe<String>;
  passwordResetToken_not_contains?: Maybe<String>;
  passwordResetToken_starts_with?: Maybe<String>;
  passwordResetToken_not_starts_with?: Maybe<String>;
  passwordResetToken_ends_with?: Maybe<String>;
  passwordResetToken_not_ends_with?: Maybe<String>;
  passwordResetTokenExpiry?: Maybe<DateTimeInput>;
  passwordResetTokenExpiry_not?: Maybe<DateTimeInput>;
  passwordResetTokenExpiry_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  passwordResetTokenExpiry_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  passwordResetTokenExpiry_lt?: Maybe<DateTimeInput>;
  passwordResetTokenExpiry_lte?: Maybe<DateTimeInput>;
  passwordResetTokenExpiry_gt?: Maybe<DateTimeInput>;
  passwordResetTokenExpiry_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface HeaderUpsertWithWhereUniqueNestedInput {
  where: HeaderWhereUniqueInput;
  update: HeaderUpdateDataInput;
  create: HeaderCreateInput;
}

export interface ObservationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  telescope?: Maybe<Telescope>;
  telescope_not?: Maybe<Telescope>;
  telescope_in?: Maybe<Telescope[] | Telescope>;
  telescope_not_in?: Maybe<Telescope[] | Telescope>;
  publicFrom?: Maybe<DateTimeInput>;
  publicFrom_not?: Maybe<DateTimeInput>;
  publicFrom_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicFrom_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicFrom_lt?: Maybe<DateTimeInput>;
  publicFrom_lte?: Maybe<DateTimeInput>;
  publicFrom_gt?: Maybe<DateTimeInput>;
  publicFrom_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ObservationScalarWhereInput[] | ObservationScalarWhereInput>;
  OR?: Maybe<ObservationScalarWhereInput[] | ObservationScalarWhereInput>;
  NOT?: Maybe<ObservationScalarWhereInput[] | ObservationScalarWhereInput>;
}

export interface HeaderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<HeaderScalarWhereInput[] | HeaderScalarWhereInput>;
  OR?: Maybe<HeaderScalarWhereInput[] | HeaderScalarWhereInput>;
  NOT?: Maybe<HeaderScalarWhereInput[] | HeaderScalarWhereInput>;
}

export interface ObservationUpdateWithoutProposalDataInput {
  name?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  telescope?: Maybe<Telescope>;
  dataFiles?: Maybe<DataFileUpdateManyWithoutObservationInput>;
  publicFrom?: Maybe<DateTimeInput>;
}

export interface HeaderUpdateManyWithWhereNestedInput {
  where: HeaderScalarWhereInput;
  data: HeaderUpdateManyDataInput;
}

export interface ObservationUpdateWithWhereUniqueWithoutProposalInput {
  where: ObservationWhereUniqueInput;
  data: ObservationUpdateWithoutProposalDataInput;
}

export interface HeaderUpdateManyDataInput {
  key?: Maybe<String>;
  value?: Maybe<String>;
}

export interface ProposalUpdateInput {
  code?: Maybe<String>;
  title?: Maybe<String>;
  abstract?: Maybe<String>;
  principalInvestigator?: Maybe<PersonUpdateOneRequiredInput>;
  observations?: Maybe<ObservationUpdateManyWithoutProposalInput>;
}

export interface DataFileUpdatepreviewsInput {
  set?: Maybe<String[] | String>;
}

export interface ObservationCreateWithoutProposalInput {
  id?: Maybe<ID_Input>;
  name: String;
  startTime: DateTimeInput;
  telescope: Telescope;
  dataFiles?: Maybe<DataFileCreateManyWithoutObservationInput>;
  publicFrom: DateTimeInput;
}

export interface ObservationUpdateOneWithoutDataFilesInput {
  create?: Maybe<ObservationCreateWithoutDataFilesInput>;
  update?: Maybe<ObservationUpdateWithoutDataFilesDataInput>;
  upsert?: Maybe<ObservationUpsertWithoutDataFilesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ObservationWhereUniqueInput>;
}

export interface ProposalCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  title: String;
  abstract: String;
  principalInvestigator: PersonCreateOneInput;
  observations?: Maybe<ObservationCreateManyWithoutProposalInput>;
}

export interface ObservationUpdateWithoutDataFilesDataInput {
  name?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  telescope?: Maybe<Telescope>;
  proposal?: Maybe<ProposalUpdateOneWithoutObservationsInput>;
  publicFrom?: Maybe<DateTimeInput>;
}

export interface PersonUpdateManyMutationInput {
  givenName?: Maybe<String>;
  familyName?: Maybe<String>;
}

export interface ProposalUpdateOneWithoutObservationsInput {
  create?: Maybe<ProposalCreateWithoutObservationsInput>;
  update?: Maybe<ProposalUpdateWithoutObservationsDataInput>;
  upsert?: Maybe<ProposalUpsertWithoutObservationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProposalWhereUniqueInput>;
}

export interface ObservationUpdateManyMutationInput {
  name?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  telescope?: Maybe<Telescope>;
  publicFrom?: Maybe<DateTimeInput>;
}

export interface DataRequestPartUpdateInput {
  dataFiles?: Maybe<DataFileUpdateManyInput>;
  status?: Maybe<DataRequestStatus>;
  statusReason?: Maybe<String>;
  uri?: Maybe<String>;
}

export interface HeaderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<HeaderWhereInput[] | HeaderWhereInput>;
  OR?: Maybe<HeaderWhereInput[] | HeaderWhereInput>;
  NOT?: Maybe<HeaderWhereInput[] | HeaderWhereInput>;
}

export interface PersonUpdateOneRequiredInput {
  create?: Maybe<PersonCreateInput>;
  update?: Maybe<PersonUpdateDataInput>;
  upsert?: Maybe<PersonUpsertNestedInput>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface DataFileUpdateWithoutObservationDataInput {
  available?: Maybe<Boolean>;
  name?: Maybe<String>;
  fitsHeadersURI?: Maybe<String>;
  headers?: Maybe<HeaderUpdateManyInput>;
  previews?: Maybe<DataFileUpdatepreviewsInput>;
  startTime?: Maybe<DateTimeInput>;
  category?: Maybe<DataCategory>;
  size?: Maybe<Int>;
}

export interface PersonUpdateDataInput {
  givenName?: Maybe<String>;
  familyName?: Maybe<String>;
}

export type ProposalWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PersonUpsertNestedInput {
  update: PersonUpdateDataInput;
  create: PersonCreateInput;
}

export interface ObservationUpdateInput {
  name?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  telescope?: Maybe<Telescope>;
  proposal?: Maybe<ProposalUpdateOneWithoutObservationsInput>;
  dataFiles?: Maybe<DataFileUpdateManyWithoutObservationInput>;
  publicFrom?: Maybe<DateTimeInput>;
}

export interface ProposalUpsertWithoutObservationsInput {
  update: ProposalUpdateWithoutObservationsDataInput;
  create: ProposalCreateWithoutObservationsInput;
}

export interface DataFileCreateManyWithoutObservationInput {
  create?: Maybe<
    | DataFileCreateWithoutObservationInput[]
    | DataFileCreateWithoutObservationInput
  >;
  connect?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
}

export interface ObservationUpsertWithoutDataFilesInput {
  update: ObservationUpdateWithoutDataFilesDataInput;
  create: ObservationCreateWithoutDataFilesInput;
}

export interface ObservationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  startTime: DateTimeInput;
  telescope: Telescope;
  proposal?: Maybe<ProposalCreateOneWithoutObservationsInput>;
  dataFiles?: Maybe<DataFileCreateManyWithoutObservationInput>;
  publicFrom: DateTimeInput;
}

export interface DataFileUpdateManyMutationInput {
  available?: Maybe<Boolean>;
  name?: Maybe<String>;
  fitsHeadersURI?: Maybe<String>;
  previews?: Maybe<DataFileUpdatepreviewsInput>;
  startTime?: Maybe<DateTimeInput>;
  category?: Maybe<DataCategory>;
  size?: Maybe<Int>;
}

export interface HeaderUpdateInput {
  key?: Maybe<String>;
  value?: Maybe<String>;
}

export interface DataRequestUpdateManyMutationInput {
  madeAt?: Maybe<DateTimeInput>;
  uri?: Maybe<String>;
}

export interface HeaderCreateManyInput {
  create?: Maybe<HeaderCreateInput[] | HeaderCreateInput>;
  connect?: Maybe<HeaderWhereUniqueInput[] | HeaderWhereUniqueInput>;
}

export interface ProposalWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  abstract?: Maybe<String>;
  abstract_not?: Maybe<String>;
  abstract_in?: Maybe<String[] | String>;
  abstract_not_in?: Maybe<String[] | String>;
  abstract_lt?: Maybe<String>;
  abstract_lte?: Maybe<String>;
  abstract_gt?: Maybe<String>;
  abstract_gte?: Maybe<String>;
  abstract_contains?: Maybe<String>;
  abstract_not_contains?: Maybe<String>;
  abstract_starts_with?: Maybe<String>;
  abstract_not_starts_with?: Maybe<String>;
  abstract_ends_with?: Maybe<String>;
  abstract_not_ends_with?: Maybe<String>;
  principalInvestigator?: Maybe<PersonWhereInput>;
  observations_every?: Maybe<ObservationWhereInput>;
  observations_some?: Maybe<ObservationWhereInput>;
  observations_none?: Maybe<ObservationWhereInput>;
  AND?: Maybe<ProposalWhereInput[] | ProposalWhereInput>;
  OR?: Maybe<ProposalWhereInput[] | ProposalWhereInput>;
  NOT?: Maybe<ProposalWhereInput[] | ProposalWhereInput>;
}

export interface PersonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  givenName?: Maybe<String>;
  givenName_not?: Maybe<String>;
  givenName_in?: Maybe<String[] | String>;
  givenName_not_in?: Maybe<String[] | String>;
  givenName_lt?: Maybe<String>;
  givenName_lte?: Maybe<String>;
  givenName_gt?: Maybe<String>;
  givenName_gte?: Maybe<String>;
  givenName_contains?: Maybe<String>;
  givenName_not_contains?: Maybe<String>;
  givenName_starts_with?: Maybe<String>;
  givenName_not_starts_with?: Maybe<String>;
  givenName_ends_with?: Maybe<String>;
  givenName_not_ends_with?: Maybe<String>;
  familyName?: Maybe<String>;
  familyName_not?: Maybe<String>;
  familyName_in?: Maybe<String[] | String>;
  familyName_not_in?: Maybe<String[] | String>;
  familyName_lt?: Maybe<String>;
  familyName_lte?: Maybe<String>;
  familyName_gt?: Maybe<String>;
  familyName_gte?: Maybe<String>;
  familyName_contains?: Maybe<String>;
  familyName_not_contains?: Maybe<String>;
  familyName_starts_with?: Maybe<String>;
  familyName_not_starts_with?: Maybe<String>;
  familyName_ends_with?: Maybe<String>;
  familyName_not_ends_with?: Maybe<String>;
  AND?: Maybe<PersonWhereInput[] | PersonWhereInput>;
  OR?: Maybe<PersonWhereInput[] | PersonWhereInput>;
  NOT?: Maybe<PersonWhereInput[] | PersonWhereInput>;
}

export interface DataRequestCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  madeAt: DateTimeInput;
  parts?: Maybe<DataRequestPartCreateManyInput>;
  uri?: Maybe<String>;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PersonWhereInput>;
  AND?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
  OR?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
  NOT?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type DataRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  familyName: String;
  givenName: String;
  username: String;
  email: String;
  affiliation: String;
  password: String;
  roles?: Maybe<UserCreaterolesInput>;
  passwordResetToken?: Maybe<String>;
  passwordResetTokenExpiry?: Maybe<DateTimeInput>;
}

export interface DataRequestPartWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  dataFiles_every?: Maybe<DataFileWhereInput>;
  dataFiles_some?: Maybe<DataFileWhereInput>;
  dataFiles_none?: Maybe<DataFileWhereInput>;
  status?: Maybe<DataRequestStatus>;
  status_not?: Maybe<DataRequestStatus>;
  status_in?: Maybe<DataRequestStatus[] | DataRequestStatus>;
  status_not_in?: Maybe<DataRequestStatus[] | DataRequestStatus>;
  statusReason?: Maybe<String>;
  statusReason_not?: Maybe<String>;
  statusReason_in?: Maybe<String[] | String>;
  statusReason_not_in?: Maybe<String[] | String>;
  statusReason_lt?: Maybe<String>;
  statusReason_lte?: Maybe<String>;
  statusReason_gt?: Maybe<String>;
  statusReason_gte?: Maybe<String>;
  statusReason_contains?: Maybe<String>;
  statusReason_not_contains?: Maybe<String>;
  statusReason_starts_with?: Maybe<String>;
  statusReason_not_starts_with?: Maybe<String>;
  statusReason_ends_with?: Maybe<String>;
  statusReason_not_ends_with?: Maybe<String>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  AND?: Maybe<DataRequestPartWhereInput[] | DataRequestPartWhereInput>;
  OR?: Maybe<DataRequestPartWhereInput[] | DataRequestPartWhereInput>;
  NOT?: Maybe<DataRequestPartWhereInput[] | DataRequestPartWhereInput>;
}

export interface UserCreaterolesInput {
  set?: Maybe<Role[] | Role>;
}

export interface DataRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  madeAt?: Maybe<DateTimeInput>;
  madeAt_not?: Maybe<DateTimeInput>;
  madeAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  madeAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  madeAt_lt?: Maybe<DateTimeInput>;
  madeAt_lte?: Maybe<DateTimeInput>;
  madeAt_gt?: Maybe<DateTimeInput>;
  madeAt_gte?: Maybe<DateTimeInput>;
  parts_every?: Maybe<DataRequestPartWhereInput>;
  parts_some?: Maybe<DataRequestPartWhereInput>;
  parts_none?: Maybe<DataRequestPartWhereInput>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  AND?: Maybe<DataRequestWhereInput[] | DataRequestWhereInput>;
  OR?: Maybe<DataRequestWhereInput[] | DataRequestWhereInput>;
  NOT?: Maybe<DataRequestWhereInput[] | DataRequestWhereInput>;
}

export interface DataRequestPartCreateManyInput {
  create?: Maybe<DataRequestPartCreateInput[] | DataRequestPartCreateInput>;
  connect?: Maybe<
    DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput
  >;
}

export interface ObservationUpsertWithWhereUniqueWithoutProposalInput {
  where: ObservationWhereUniqueInput;
  update: ObservationUpdateWithoutProposalDataInput;
  create: ObservationCreateWithoutProposalInput;
}

export interface DataRequestPartCreateInput {
  id?: Maybe<ID_Input>;
  dataFiles?: Maybe<DataFileCreateManyInput>;
  status?: Maybe<DataRequestStatus>;
  statusReason?: Maybe<String>;
  uri?: Maybe<String>;
}

export interface ObservationUpdateManyWithoutProposalInput {
  create?: Maybe<
    | ObservationCreateWithoutProposalInput[]
    | ObservationCreateWithoutProposalInput
  >;
  delete?: Maybe<ObservationWhereUniqueInput[] | ObservationWhereUniqueInput>;
  connect?: Maybe<ObservationWhereUniqueInput[] | ObservationWhereUniqueInput>;
  set?: Maybe<ObservationWhereUniqueInput[] | ObservationWhereUniqueInput>;
  disconnect?: Maybe<
    ObservationWhereUniqueInput[] | ObservationWhereUniqueInput
  >;
  update?: Maybe<
    | ObservationUpdateWithWhereUniqueWithoutProposalInput[]
    | ObservationUpdateWithWhereUniqueWithoutProposalInput
  >;
  upsert?: Maybe<
    | ObservationUpsertWithWhereUniqueWithoutProposalInput[]
    | ObservationUpsertWithWhereUniqueWithoutProposalInput
  >;
  deleteMany?: Maybe<
    ObservationScalarWhereInput[] | ObservationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ObservationUpdateManyWithWhereNestedInput[]
    | ObservationUpdateManyWithWhereNestedInput
  >;
}

export interface DataFileCreateManyInput {
  create?: Maybe<DataFileCreateInput[] | DataFileCreateInput>;
  connect?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
}

export interface ObservationCreateManyWithoutProposalInput {
  create?: Maybe<
    | ObservationCreateWithoutProposalInput[]
    | ObservationCreateWithoutProposalInput
  >;
  connect?: Maybe<ObservationWhereUniqueInput[] | ObservationWhereUniqueInput>;
}

export interface DataRequestUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  madeAt?: Maybe<DateTimeInput>;
  parts?: Maybe<DataRequestPartUpdateManyInput>;
  uri?: Maybe<String>;
}

export interface PersonUpdateInput {
  givenName?: Maybe<String>;
  familyName?: Maybe<String>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface DataFileUpsertWithWhereUniqueWithoutObservationInput {
  where: DataFileWhereUniqueInput;
  update: DataFileUpdateWithoutObservationDataInput;
  create: DataFileCreateWithoutObservationInput;
}

export interface UserUpdateDataInput {
  familyName?: Maybe<String>;
  givenName?: Maybe<String>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  affiliation?: Maybe<String>;
  password?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
  passwordResetToken?: Maybe<String>;
  passwordResetTokenExpiry?: Maybe<DateTimeInput>;
}

export interface DataFileUpdateManyWithoutObservationInput {
  create?: Maybe<
    | DataFileCreateWithoutObservationInput[]
    | DataFileCreateWithoutObservationInput
  >;
  delete?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
  connect?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
  set?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
  disconnect?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
  update?: Maybe<
    | DataFileUpdateWithWhereUniqueWithoutObservationInput[]
    | DataFileUpdateWithWhereUniqueWithoutObservationInput
  >;
  upsert?: Maybe<
    | DataFileUpsertWithWhereUniqueWithoutObservationInput[]
    | DataFileUpsertWithWhereUniqueWithoutObservationInput
  >;
  deleteMany?: Maybe<DataFileScalarWhereInput[] | DataFileScalarWhereInput>;
  updateMany?: Maybe<
    | DataFileUpdateManyWithWhereNestedInput[]
    | DataFileUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdaterolesInput {
  set?: Maybe<Role[] | Role>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  passwordResetToken?: Maybe<String>;
}>;

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface DataRequestPartUpdateManyMutationInput {
  status?: Maybe<DataRequestStatus>;
  statusReason?: Maybe<String>;
  uri?: Maybe<String>;
}

export interface DataRequestPartUpdateManyInput {
  create?: Maybe<DataRequestPartCreateInput[] | DataRequestPartCreateInput>;
  update?: Maybe<
    | DataRequestPartUpdateWithWhereUniqueNestedInput[]
    | DataRequestPartUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | DataRequestPartUpsertWithWhereUniqueNestedInput[]
    | DataRequestPartUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput
  >;
  connect?: Maybe<
    DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput
  >;
  set?: Maybe<
    DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput
  >;
  disconnect?: Maybe<
    DataRequestPartWhereUniqueInput[] | DataRequestPartWhereUniqueInput
  >;
  deleteMany?: Maybe<
    DataRequestPartScalarWhereInput[] | DataRequestPartScalarWhereInput
  >;
  updateMany?: Maybe<
    | DataRequestPartUpdateManyWithWhereNestedInput[]
    | DataRequestPartUpdateManyWithWhereNestedInput
  >;
}

export interface HeaderCreateInput {
  id?: Maybe<ID_Input>;
  key: String;
  value?: Maybe<String>;
}

export interface DataRequestPartUpdateWithWhereUniqueNestedInput {
  where: DataRequestPartWhereUniqueInput;
  data: DataRequestPartUpdateDataInput;
}

export interface HeaderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HeaderWhereInput>;
  AND?: Maybe<HeaderSubscriptionWhereInput[] | HeaderSubscriptionWhereInput>;
  OR?: Maybe<HeaderSubscriptionWhereInput[] | HeaderSubscriptionWhereInput>;
  NOT?: Maybe<HeaderSubscriptionWhereInput[] | HeaderSubscriptionWhereInput>;
}

export interface DataRequestPartUpdateDataInput {
  dataFiles?: Maybe<DataFileUpdateManyInput>;
  status?: Maybe<DataRequestStatus>;
  statusReason?: Maybe<String>;
  uri?: Maybe<String>;
}

export interface ProposalUpdateManyMutationInput {
  code?: Maybe<String>;
  title?: Maybe<String>;
  abstract?: Maybe<String>;
}

export interface DataFileUpdateManyInput {
  create?: Maybe<DataFileCreateInput[] | DataFileCreateInput>;
  update?: Maybe<
    | DataFileUpdateWithWhereUniqueNestedInput[]
    | DataFileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | DataFileUpsertWithWhereUniqueNestedInput[]
    | DataFileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
  connect?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
  set?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
  disconnect?: Maybe<DataFileWhereUniqueInput[] | DataFileWhereUniqueInput>;
  deleteMany?: Maybe<DataFileScalarWhereInput[] | DataFileScalarWhereInput>;
  updateMany?: Maybe<
    | DataFileUpdateManyWithWhereNestedInput[]
    | DataFileUpdateManyWithWhereNestedInput
  >;
}

export type DataRequestPartWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DataFileUpdateWithWhereUniqueNestedInput {
  where: DataFileWhereUniqueInput;
  data: DataFileUpdateDataInput;
}

export type ObservationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DataFileUpdateDataInput {
  available?: Maybe<Boolean>;
  name?: Maybe<String>;
  fitsHeadersURI?: Maybe<String>;
  headers?: Maybe<HeaderUpdateManyInput>;
  previews?: Maybe<DataFileUpdatepreviewsInput>;
  startTime?: Maybe<DateTimeInput>;
  category?: Maybe<DataCategory>;
  observation?: Maybe<ObservationUpdateOneWithoutDataFilesInput>;
  size?: Maybe<Int>;
}

export interface DataFileUpdateWithWhereUniqueWithoutObservationInput {
  where: DataFileWhereUniqueInput;
  data: DataFileUpdateWithoutObservationDataInput;
}

export interface DataFileUpsertWithWhereUniqueNestedInput {
  where: DataFileWhereUniqueInput;
  update: DataFileUpdateDataInput;
  create: DataFileCreateInput;
}

export interface HeaderUpdateManyMutationInput {
  key?: Maybe<String>;
  value?: Maybe<String>;
}

export interface DataFileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  fitsHeadersURI?: Maybe<String>;
  fitsHeadersURI_not?: Maybe<String>;
  fitsHeadersURI_in?: Maybe<String[] | String>;
  fitsHeadersURI_not_in?: Maybe<String[] | String>;
  fitsHeadersURI_lt?: Maybe<String>;
  fitsHeadersURI_lte?: Maybe<String>;
  fitsHeadersURI_gt?: Maybe<String>;
  fitsHeadersURI_gte?: Maybe<String>;
  fitsHeadersURI_contains?: Maybe<String>;
  fitsHeadersURI_not_contains?: Maybe<String>;
  fitsHeadersURI_starts_with?: Maybe<String>;
  fitsHeadersURI_not_starts_with?: Maybe<String>;
  fitsHeadersURI_ends_with?: Maybe<String>;
  fitsHeadersURI_not_ends_with?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  category?: Maybe<DataCategory>;
  category_not?: Maybe<DataCategory>;
  category_in?: Maybe<DataCategory[] | DataCategory>;
  category_not_in?: Maybe<DataCategory[] | DataCategory>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  AND?: Maybe<DataFileScalarWhereInput[] | DataFileScalarWhereInput>;
  OR?: Maybe<DataFileScalarWhereInput[] | DataFileScalarWhereInput>;
  NOT?: Maybe<DataFileScalarWhereInput[] | DataFileScalarWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface DataFileUpdateManyWithWhereNestedInput {
  where: DataFileScalarWhereInput;
  data: DataFileUpdateManyDataInput;
}

export interface ObservationUpdateManyWithWhereNestedInput {
  where: ObservationScalarWhereInput;
  data: ObservationUpdateManyDataInput;
}

export interface DataRequestPartUpdateManyWithWhereNestedInput {
  where: DataRequestPartScalarWhereInput;
  data: DataRequestPartUpdateManyDataInput;
}

export interface DataRequestPartScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<DataRequestStatus>;
  status_not?: Maybe<DataRequestStatus>;
  status_in?: Maybe<DataRequestStatus[] | DataRequestStatus>;
  status_not_in?: Maybe<DataRequestStatus[] | DataRequestStatus>;
  statusReason?: Maybe<String>;
  statusReason_not?: Maybe<String>;
  statusReason_in?: Maybe<String[] | String>;
  statusReason_not_in?: Maybe<String[] | String>;
  statusReason_lt?: Maybe<String>;
  statusReason_lte?: Maybe<String>;
  statusReason_gt?: Maybe<String>;
  statusReason_gte?: Maybe<String>;
  statusReason_contains?: Maybe<String>;
  statusReason_not_contains?: Maybe<String>;
  statusReason_starts_with?: Maybe<String>;
  statusReason_not_starts_with?: Maybe<String>;
  statusReason_ends_with?: Maybe<String>;
  statusReason_not_ends_with?: Maybe<String>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    DataRequestPartScalarWhereInput[] | DataRequestPartScalarWhereInput
  >;
  OR?: Maybe<
    DataRequestPartScalarWhereInput[] | DataRequestPartScalarWhereInput
  >;
  NOT?: Maybe<
    DataRequestPartScalarWhereInput[] | DataRequestPartScalarWhereInput
  >;
}

export interface DataRequestPartUpsertWithWhereUniqueNestedInput {
  where: DataRequestPartWhereUniqueInput;
  update: DataRequestPartUpdateDataInput;
  create: DataRequestPartCreateInput;
}

export interface DataFileUpdateManyDataInput {
  available?: Maybe<Boolean>;
  name?: Maybe<String>;
  fitsHeadersURI?: Maybe<String>;
  previews?: Maybe<DataFileUpdatepreviewsInput>;
  startTime?: Maybe<DateTimeInput>;
  category?: Maybe<DataCategory>;
  size?: Maybe<Int>;
}

export type HeaderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DataFileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DataFileWhereInput>;
  AND?: Maybe<
    DataFileSubscriptionWhereInput[] | DataFileSubscriptionWhereInput
  >;
  OR?: Maybe<DataFileSubscriptionWhereInput[] | DataFileSubscriptionWhereInput>;
  NOT?: Maybe<
    DataFileSubscriptionWhereInput[] | DataFileSubscriptionWhereInput
  >;
}

export interface DataFileCreateInput {
  id?: Maybe<ID_Input>;
  available?: Maybe<Boolean>;
  name: String;
  fitsHeadersURI?: Maybe<String>;
  headers?: Maybe<HeaderCreateManyInput>;
  previews?: Maybe<DataFileCreatepreviewsInput>;
  startTime?: Maybe<DateTimeInput>;
  category: DataCategory;
  observation?: Maybe<ObservationCreateOneWithoutDataFilesInput>;
  size?: Maybe<Int>;
}

export interface DataFileCreateWithoutObservationInput {
  id?: Maybe<ID_Input>;
  available?: Maybe<Boolean>;
  name: String;
  fitsHeadersURI?: Maybe<String>;
  headers?: Maybe<HeaderCreateManyInput>;
  previews?: Maybe<DataFileCreatepreviewsInput>;
  startTime?: Maybe<DateTimeInput>;
  category: DataCategory;
  size?: Maybe<Int>;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  familyName: String;
  givenName: String;
  username: String;
  email: String;
  affiliation: String;
  password: String;
  roles: Role[];
  passwordResetToken?: String;
  passwordResetTokenExpiry?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  familyName: () => Promise<String>;
  givenName: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  affiliation: () => Promise<String>;
  password: () => Promise<String>;
  roles: () => Promise<Role[]>;
  passwordResetToken: () => Promise<String>;
  passwordResetTokenExpiry: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  familyName: () => Promise<AsyncIterator<String>>;
  givenName: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  affiliation: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<Role[]>>;
  passwordResetToken: () => Promise<AsyncIterator<String>>;
  passwordResetTokenExpiry: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Header {
  id: ID_Output;
  key: String;
  value?: String;
}

export interface HeaderPromise extends Promise<Header>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface HeaderSubscription
  extends Promise<AsyncIterator<Header>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface HeaderNullablePromise
  extends Promise<Header | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DataRequestPart {
  id: ID_Output;
  status: DataRequestStatus;
  statusReason: String;
  uri?: String;
}

export interface DataRequestPartPromise
  extends Promise<DataRequestPart>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dataFiles: <T = FragmentableArray<DataFile>>(args?: {
    where?: DataFileWhereInput;
    orderBy?: DataFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<DataRequestStatus>;
  statusReason: () => Promise<String>;
  uri: () => Promise<String>;
}

export interface DataRequestPartSubscription
  extends Promise<AsyncIterator<DataRequestPart>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dataFiles: <T = Promise<AsyncIterator<DataFileSubscription>>>(args?: {
    where?: DataFileWhereInput;
    orderBy?: DataFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<DataRequestStatus>>;
  statusReason: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestPartNullablePromise
  extends Promise<DataRequestPart | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  dataFiles: <T = FragmentableArray<DataFile>>(args?: {
    where?: DataFileWhereInput;
    orderBy?: DataFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<DataRequestStatus>;
  statusReason: () => Promise<String>;
  uri: () => Promise<String>;
}

export interface Proposal {
  id: ID_Output;
  code: String;
  title: String;
  abstract: String;
}

export interface ProposalPromise extends Promise<Proposal>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  title: () => Promise<String>;
  abstract: () => Promise<String>;
  principalInvestigator: <T = PersonPromise>() => T;
  observations: <T = FragmentableArray<Observation>>(args?: {
    where?: ObservationWhereInput;
    orderBy?: ObservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProposalSubscription
  extends Promise<AsyncIterator<Proposal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  abstract: () => Promise<AsyncIterator<String>>;
  principalInvestigator: <T = PersonSubscription>() => T;
  observations: <T = Promise<AsyncIterator<ObservationSubscription>>>(args?: {
    where?: ObservationWhereInput;
    orderBy?: ObservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProposalNullablePromise
  extends Promise<Proposal | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  title: () => Promise<String>;
  abstract: () => Promise<String>;
  principalInvestigator: <T = PersonPromise>() => T;
  observations: <T = FragmentableArray<Observation>>(args?: {
    where?: ObservationWhereInput;
    orderBy?: ObservationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProposalSubscriptionPayload {
  mutation: MutationType;
  node: Proposal;
  updatedFields: String[];
  previousValues: ProposalPreviousValues;
}

export interface ProposalSubscriptionPayloadPromise
  extends Promise<ProposalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProposalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProposalPreviousValuesPromise>() => T;
}

export interface ProposalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProposalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProposalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProposalPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Observation {
  id: ID_Output;
  name: String;
  startTime: DateTimeOutput;
  telescope: Telescope;
  publicFrom: DateTimeOutput;
}

export interface ObservationPromise extends Promise<Observation>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  telescope: () => Promise<Telescope>;
  proposal: <T = ProposalPromise>() => T;
  dataFiles: <T = FragmentableArray<DataFile>>(args?: {
    where?: DataFileWhereInput;
    orderBy?: DataFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publicFrom: () => Promise<DateTimeOutput>;
}

export interface ObservationSubscription
  extends Promise<AsyncIterator<Observation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  telescope: () => Promise<AsyncIterator<Telescope>>;
  proposal: <T = ProposalSubscription>() => T;
  dataFiles: <T = Promise<AsyncIterator<DataFileSubscription>>>(args?: {
    where?: DataFileWhereInput;
    orderBy?: DataFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publicFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ObservationNullablePromise
  extends Promise<Observation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  telescope: () => Promise<Telescope>;
  proposal: <T = ProposalPromise>() => T;
  dataFiles: <T = FragmentableArray<DataFile>>(args?: {
    where?: DataFileWhereInput;
    orderBy?: DataFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publicFrom: () => Promise<DateTimeOutput>;
}

export interface ProposalEdge {
  node: Proposal;
  cursor: String;
}

export interface ProposalEdgePromise
  extends Promise<ProposalEdge>,
    Fragmentable {
  node: <T = ProposalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProposalEdgeSubscription
  extends Promise<AsyncIterator<ProposalEdge>>,
    Fragmentable {
  node: <T = ProposalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  familyName: String;
  givenName: String;
  username: String;
  email: String;
  affiliation: String;
  password: String;
  roles: Role[];
  passwordResetToken?: String;
  passwordResetTokenExpiry?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  familyName: () => Promise<String>;
  givenName: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  affiliation: () => Promise<String>;
  password: () => Promise<String>;
  roles: () => Promise<Role[]>;
  passwordResetToken: () => Promise<String>;
  passwordResetTokenExpiry: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  familyName: () => Promise<AsyncIterator<String>>;
  givenName: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  affiliation: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<Role[]>>;
  passwordResetToken: () => Promise<AsyncIterator<String>>;
  passwordResetTokenExpiry: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  familyName: () => Promise<String>;
  givenName: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  affiliation: () => Promise<String>;
  password: () => Promise<String>;
  roles: () => Promise<Role[]>;
  passwordResetToken: () => Promise<String>;
  passwordResetTokenExpiry: () => Promise<DateTimeOutput>;
}

export interface Person {
  id: ID_Output;
  givenName: String;
  familyName: String;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  id: () => Promise<ID_Output>;
  givenName: () => Promise<String>;
  familyName: () => Promise<String>;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  givenName: () => Promise<AsyncIterator<String>>;
  familyName: () => Promise<AsyncIterator<String>>;
}

export interface PersonNullablePromise
  extends Promise<Person | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  givenName: () => Promise<String>;
  familyName: () => Promise<String>;
}

export interface DataFile {
  id: ID_Output;
  available: Boolean;
  name: String;
  fitsHeadersURI?: String;
  previews: String[];
  startTime?: DateTimeOutput;
  category: DataCategory;
  size?: Int;
}

export interface DataFilePromise extends Promise<DataFile>, Fragmentable {
  id: () => Promise<ID_Output>;
  available: () => Promise<Boolean>;
  name: () => Promise<String>;
  fitsHeadersURI: () => Promise<String>;
  headers: <T = FragmentableArray<Header>>(args?: {
    where?: HeaderWhereInput;
    orderBy?: HeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  previews: () => Promise<String[]>;
  startTime: () => Promise<DateTimeOutput>;
  category: () => Promise<DataCategory>;
  observation: <T = ObservationPromise>() => T;
  size: () => Promise<Int>;
}

export interface DataFileSubscription
  extends Promise<AsyncIterator<DataFile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  fitsHeadersURI: () => Promise<AsyncIterator<String>>;
  headers: <T = Promise<AsyncIterator<HeaderSubscription>>>(args?: {
    where?: HeaderWhereInput;
    orderBy?: HeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  previews: () => Promise<AsyncIterator<String[]>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: () => Promise<AsyncIterator<DataCategory>>;
  observation: <T = ObservationSubscription>() => T;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface DataFileNullablePromise
  extends Promise<DataFile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  available: () => Promise<Boolean>;
  name: () => Promise<String>;
  fitsHeadersURI: () => Promise<String>;
  headers: <T = FragmentableArray<Header>>(args?: {
    where?: HeaderWhereInput;
    orderBy?: HeaderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  previews: () => Promise<String[]>;
  startTime: () => Promise<DateTimeOutput>;
  category: () => Promise<DataCategory>;
  observation: <T = ObservationPromise>() => T;
  size: () => Promise<Int>;
}

export interface PersonEdge {
  node: Person;
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DataFileSubscriptionPayload {
  mutation: MutationType;
  node: DataFile;
  updatedFields: String[];
  previousValues: DataFilePreviousValues;
}

export interface DataFileSubscriptionPayloadPromise
  extends Promise<DataFileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataFilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataFilePreviousValuesPromise>() => T;
}

export interface DataFileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataFileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataFileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataFilePreviousValuesSubscription>() => T;
}

export interface AggregateObservation {
  count: Int;
}

export interface AggregateObservationPromise
  extends Promise<AggregateObservation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateObservationSubscription
  extends Promise<AsyncIterator<AggregateObservation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataFilePreviousValues {
  id: ID_Output;
  available: Boolean;
  name: String;
  fitsHeadersURI?: String;
  previews: String[];
  startTime?: DateTimeOutput;
  category: DataCategory;
  size?: Int;
}

export interface DataFilePreviousValuesPromise
  extends Promise<DataFilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  available: () => Promise<Boolean>;
  name: () => Promise<String>;
  fitsHeadersURI: () => Promise<String>;
  previews: () => Promise<String[]>;
  startTime: () => Promise<DateTimeOutput>;
  category: () => Promise<DataCategory>;
  size: () => Promise<Int>;
}

export interface DataFilePreviousValuesSubscription
  extends Promise<AsyncIterator<DataFilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  available: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  fitsHeadersURI: () => Promise<AsyncIterator<String>>;
  previews: () => Promise<AsyncIterator<String[]>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: () => Promise<AsyncIterator<DataCategory>>;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface ObservationConnection {
  pageInfo: PageInfo;
  edges: ObservationEdge[];
}

export interface ObservationConnectionPromise
  extends Promise<ObservationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ObservationEdge>>() => T;
  aggregate: <T = AggregateObservationPromise>() => T;
}

export interface ObservationConnectionSubscription
  extends Promise<AsyncIterator<ObservationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ObservationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateObservationSubscription>() => T;
}

export interface DataRequest {
  id: ID_Output;
  madeAt: DateTimeOutput;
  uri?: String;
}

export interface DataRequestPromise extends Promise<DataRequest>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  madeAt: () => Promise<DateTimeOutput>;
  parts: <T = FragmentableArray<DataRequestPart>>(args?: {
    where?: DataRequestPartWhereInput;
    orderBy?: DataRequestPartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uri: () => Promise<String>;
}

export interface DataRequestSubscription
  extends Promise<AsyncIterator<DataRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  madeAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  parts: <T = Promise<AsyncIterator<DataRequestPartSubscription>>>(args?: {
    where?: DataRequestPartWhereInput;
    orderBy?: DataRequestPartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestNullablePromise
  extends Promise<DataRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  madeAt: () => Promise<DateTimeOutput>;
  parts: <T = FragmentableArray<DataRequestPart>>(args?: {
    where?: DataRequestPartWhereInput;
    orderBy?: DataRequestPartOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  uri: () => Promise<String>;
}

export interface HeaderEdge {
  node: Header;
  cursor: String;
}

export interface HeaderEdgePromise extends Promise<HeaderEdge>, Fragmentable {
  node: <T = HeaderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HeaderEdgeSubscription
  extends Promise<AsyncIterator<HeaderEdge>>,
    Fragmentable {
  node: <T = HeaderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestSubscriptionPayload {
  mutation: MutationType;
  node: DataRequest;
  updatedFields: String[];
  previousValues: DataRequestPreviousValues;
}

export interface DataRequestSubscriptionPayloadPromise
  extends Promise<DataRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataRequestPreviousValuesPromise>() => T;
}

export interface DataRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataRequestPreviousValuesSubscription>() => T;
}

export interface AggregateDataRequestPart {
  count: Int;
}

export interface AggregateDataRequestPartPromise
  extends Promise<AggregateDataRequestPart>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataRequestPartSubscription
  extends Promise<AsyncIterator<AggregateDataRequestPart>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataRequestPreviousValues {
  id: ID_Output;
  madeAt: DateTimeOutput;
  uri?: String;
}

export interface DataRequestPreviousValuesPromise
  extends Promise<DataRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  madeAt: () => Promise<DateTimeOutput>;
  uri: () => Promise<String>;
}

export interface DataRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<DataRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  madeAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestPartConnection {
  pageInfo: PageInfo;
  edges: DataRequestPartEdge[];
}

export interface DataRequestPartConnectionPromise
  extends Promise<DataRequestPartConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataRequestPartEdge>>() => T;
  aggregate: <T = AggregateDataRequestPartPromise>() => T;
}

export interface DataRequestPartConnectionSubscription
  extends Promise<AsyncIterator<DataRequestPartConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataRequestPartEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataRequestPartSubscription>() => T;
}

export interface AggregateDataFile {
  count: Int;
}

export interface AggregateDataFilePromise
  extends Promise<AggregateDataFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataFileSubscription
  extends Promise<AsyncIterator<AggregateDataFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataRequestEdge {
  node: DataRequest;
  cursor: String;
}

export interface DataRequestEdgePromise
  extends Promise<DataRequestEdge>,
    Fragmentable {
  node: <T = DataRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataRequestEdgeSubscription
  extends Promise<AsyncIterator<DataRequestEdge>>,
    Fragmentable {
  node: <T = DataRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestPartSubscriptionPayload {
  mutation: MutationType;
  node: DataRequestPart;
  updatedFields: String[];
  previousValues: DataRequestPartPreviousValues;
}

export interface DataRequestPartSubscriptionPayloadPromise
  extends Promise<DataRequestPartSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DataRequestPartPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DataRequestPartPreviousValuesPromise>() => T;
}

export interface DataRequestPartSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DataRequestPartSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DataRequestPartSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DataRequestPartPreviousValuesSubscription>() => T;
}

export interface ProposalPreviousValues {
  id: ID_Output;
  code: String;
  title: String;
  abstract: String;
}

export interface ProposalPreviousValuesPromise
  extends Promise<ProposalPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  title: () => Promise<String>;
  abstract: () => Promise<String>;
}

export interface ProposalPreviousValuesSubscription
  extends Promise<AsyncIterator<ProposalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  abstract: () => Promise<AsyncIterator<String>>;
}

export interface DataRequestPartPreviousValues {
  id: ID_Output;
  status: DataRequestStatus;
  statusReason: String;
  uri?: String;
}

export interface DataRequestPartPreviousValuesPromise
  extends Promise<DataRequestPartPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<DataRequestStatus>;
  statusReason: () => Promise<String>;
  uri: () => Promise<String>;
}

export interface DataRequestPartPreviousValuesSubscription
  extends Promise<AsyncIterator<DataRequestPartPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<DataRequestStatus>>;
  statusReason: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProposal {
  count: Int;
}

export interface AggregateProposalPromise
  extends Promise<AggregateProposal>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProposalSubscription
  extends Promise<AsyncIterator<AggregateProposal>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DataFileEdge {
  node: DataFile;
  cursor: String;
}

export interface DataFileEdgePromise
  extends Promise<DataFileEdge>,
    Fragmentable {
  node: <T = DataFilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataFileEdgeSubscription
  extends Promise<AsyncIterator<DataFileEdge>>,
    Fragmentable {
  node: <T = DataFileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HeaderSubscriptionPayload {
  mutation: MutationType;
  node: Header;
  updatedFields: String[];
  previousValues: HeaderPreviousValues;
}

export interface HeaderSubscriptionPayloadPromise
  extends Promise<HeaderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HeaderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HeaderPreviousValuesPromise>() => T;
}

export interface HeaderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HeaderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HeaderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HeaderPreviousValuesSubscription>() => T;
}

export interface ObservationEdge {
  node: Observation;
  cursor: String;
}

export interface ObservationEdgePromise
  extends Promise<ObservationEdge>,
    Fragmentable {
  node: <T = ObservationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ObservationEdgeSubscription
  extends Promise<AsyncIterator<ObservationEdge>>,
    Fragmentable {
  node: <T = ObservationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HeaderPreviousValues {
  id: ID_Output;
  key: String;
  value?: String;
}

export interface HeaderPreviousValuesPromise
  extends Promise<HeaderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  value: () => Promise<String>;
}

export interface HeaderPreviousValuesSubscription
  extends Promise<AsyncIterator<HeaderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface HeaderConnection {
  pageInfo: PageInfo;
  edges: HeaderEdge[];
}

export interface HeaderConnectionPromise
  extends Promise<HeaderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HeaderEdge>>() => T;
  aggregate: <T = AggregateHeaderPromise>() => T;
}

export interface HeaderConnectionSubscription
  extends Promise<AsyncIterator<HeaderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HeaderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHeaderSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDataRequest {
  count: Int;
}

export interface AggregateDataRequestPromise
  extends Promise<AggregateDataRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDataRequestSubscription
  extends Promise<AsyncIterator<AggregateDataRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ObservationSubscriptionPayload {
  mutation: MutationType;
  node: Observation;
  updatedFields: String[];
  previousValues: ObservationPreviousValues;
}

export interface ObservationSubscriptionPayloadPromise
  extends Promise<ObservationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ObservationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ObservationPreviousValuesPromise>() => T;
}

export interface ObservationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ObservationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ObservationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ObservationPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PersonConnection {
  pageInfo: PageInfo;
  edges: PersonEdge[];
}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface PersonPreviousValues {
  id: ID_Output;
  givenName: String;
  familyName: String;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  givenName: () => Promise<String>;
  familyName: () => Promise<String>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  givenName: () => Promise<AsyncIterator<String>>;
  familyName: () => Promise<AsyncIterator<String>>;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  node: Person;
  updatedFields: String[];
  previousValues: PersonPreviousValues;
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface DataFileConnection {
  pageInfo: PageInfo;
  edges: DataFileEdge[];
}

export interface DataFileConnectionPromise
  extends Promise<DataFileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataFileEdge>>() => T;
  aggregate: <T = AggregateDataFilePromise>() => T;
}

export interface DataFileConnectionSubscription
  extends Promise<AsyncIterator<DataFileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataFileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataFileSubscription>() => T;
}

export interface ObservationPreviousValues {
  id: ID_Output;
  name: String;
  startTime: DateTimeOutput;
  telescope: Telescope;
  publicFrom: DateTimeOutput;
}

export interface ObservationPreviousValuesPromise
  extends Promise<ObservationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  telescope: () => Promise<Telescope>;
  publicFrom: () => Promise<DateTimeOutput>;
}

export interface ObservationPreviousValuesSubscription
  extends Promise<AsyncIterator<ObservationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  telescope: () => Promise<AsyncIterator<Telescope>>;
  publicFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateHeader {
  count: Int;
}

export interface AggregateHeaderPromise
  extends Promise<AggregateHeader>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHeaderSubscription
  extends Promise<AsyncIterator<AggregateHeader>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProposalConnection {
  pageInfo: PageInfo;
  edges: ProposalEdge[];
}

export interface ProposalConnectionPromise
  extends Promise<ProposalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProposalEdge>>() => T;
  aggregate: <T = AggregateProposalPromise>() => T;
}

export interface ProposalConnectionSubscription
  extends Promise<AsyncIterator<ProposalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProposalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProposalSubscription>() => T;
}

export interface DataRequestConnection {
  pageInfo: PageInfo;
  edges: DataRequestEdge[];
}

export interface DataRequestConnectionPromise
  extends Promise<DataRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DataRequestEdge>>() => T;
  aggregate: <T = AggregateDataRequestPromise>() => T;
}

export interface DataRequestConnectionSubscription
  extends Promise<AsyncIterator<DataRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DataRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDataRequestSubscription>() => T;
}

export interface DataRequestPartEdge {
  node: DataRequestPart;
  cursor: String;
}

export interface DataRequestPartEdgePromise
  extends Promise<DataRequestPartEdge>,
    Fragmentable {
  node: <T = DataRequestPartPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DataRequestPartEdgeSubscription
  extends Promise<AsyncIterator<DataRequestPartEdge>>,
    Fragmentable {
  node: <T = DataRequestPartSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "DataRequestStatus",
    embedded: false
  },
  {
    name: "DataCategory",
    embedded: false
  },
  {
    name: "Telescope",
    embedded: false
  },
  {
    name: "Header",
    embedded: false
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "Proposal",
    embedded: false
  },
  {
    name: "Observation",
    embedded: false
  },
  {
    name: "DataFile",
    embedded: false
  },
  {
    name: "DataRequest",
    embedded: false
  },
  {
    name: "DataRequestPart",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
